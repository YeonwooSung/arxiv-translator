<!DOCTYPE html>
<html lang="en" data-lt-installed="true"><head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    const text = '' +
      '# Billion-scale similarity search with GPUs\n' +
      '\n' +
      ' Jeff Johnson\n' +
      '\n' +
      'Facebook AI Research\n' +
      '\n' +
      'Matthijs Douze\n' +
      '\n' +
      'Facebook AI Research\n' +
      '\n' +
      'Paris\n' +
      '\n' +
      'Herve Jegou\n' +
      '\n' +
      'Facebook AI Research\n' +
      '\n' +
      '###### Abstract\n' +
      '\n' +
      'Similarity search finds application in specialized database systems handling complex data such as images or videos, which are typically represented by high-dimensional features and require specific indexing structures. This paper tackles the problem of better utilizing GPUs for this task. While GPUs excel at data-parallel tasks, prior approaches are bottlenecked by algorithms that expose less parallelism, such as \\(k\\)-min selection, or make poor use of the memory hierarchy.\n' +
      '\n' +
      'We propose a design for \\(k\\)-selection that operates at up to 55% of theoretical peak performance, enabling a nearest neighbor implementation that is 8.5\\(\\times\\) faster than prior GPU state of the art. We apply it in different similarity search scenarios, by proposing optimized design for brute-force, approximate and compressed-domain search based on product quantization. In all these setups, we outperform the state of the art by large margins. Our implementation enables the construction of a high accuracy \\(k\\)-NN graph on 95 million images from the Yfcc100M dataset in 35 minutes, and of a graph connecting 1 billion vectors in less than 12 hours on 4 Maxwell Titan X GPUs. We have open-sourced our approach1 for the sake of comparison and reproducibility.\n' +
      '\n' +
      'Footnote 1: [https://github.com/facebookresearch/faiss](https://github.com/facebookresearch/faiss)\n' +
      '\n' +
      '1\n' +
      '\n' +
      '## 1 Introduction\n' +
      '\n' +
      'Images and videos constitute a new massive source of data for indexing and search. Extensive metadata for this content is often not available. Search and interpretation of this and other human-generated content, like text, is difficult and important. A variety of machine learning and deep learning algorithms are being used to interpret and classify these complex, real-world entities. Popular examples include the text representation known as word2vec [32], representations of images by convolutional neural networks [39, 19], and image descriptors for instance search [20]. Such representations or _embeddings_ are usually real-valued, high-dimensional vectors of 50 to 1000+ dimensions. Many of these vector representations can only effectively be produced on GPU systems, as the underlying processes either have high arithmetic complexity and/or high data bandwidth demands [28], or cannot be effectively partitioned without failing due to communication overhead or representation quality [38]. Once produced, their manipulation is itself arithmetically intensive. However, how to utilize GPU assets is not straightforward. More generally, how to exploit new heterogeneous architectures is a key subject for the database community [9].\n' +
      '\n' +
      'In this context, searching by numerical _similarity_ rather than via structured relations is more suitable. This could be to find the most similar content to a picture, or to find the vectors that have the highest response to a linear classifier on all vectors of a collection.\n' +
      '\n' +
      'One of the most expensive operations to be performed on large collections is to compute a \\(k\\)-NN graph. It is a directed graph where each vector of the database is a node and each edge connects a node to its \\(k\\) nearest neighbors. This is our flagship application. Note, state of the art methods like NN-Descent [15] have a large memory overhead on top of the dataset itself and cannot readily scale to the billion-sized databases we consider.\n' +
      '\n' +
      'Such applications must deal with the _curse of dimensionality_[46], rendering both exhaustive search or exact indexing for non-exhaustive search impractical on billion-scale databases. This is why there is a large body of work on approximate search and/or graph construction. To handle huge datasets that do not fit in RAM, several approaches employ an internal compressed representation of the vectors using an encoding. This is especially convenient for memory-limited devices like GPUs. It turns out that accepting a minimal accuracy loss results in orders of magnitude of compression [21]. The most popular vector compression methods can be classified into either binary codes [18, 22], or quantization methods [25, 37]. Both have the desirable property that searching neighbors does not require reconstructing the vectors.\n' +
      '\n' +
      'Our paper focuses on methods based on product quantization (PQ) codes, as these were shown to be more effective than binary codes [34]. In addition, binary codes incur important overheads for non-exhaustive search methods [35]. Several improvements were proposed after the original product quantization proposal known as IVFADC [25]; most are difficult to implement efficiently on GPU. For instance, the inverted multi-index [4], useful for high-speed/low-quality operating points, depends on a complicated "multi-sequence" algorithm. The optimized product quantization or OPQ [17] is a linear transformation on the input vectors that improves the accuracy of the product quantization; it can be appliedas a pre-processing. The SIMD-optimized IVFADC implementation from [2] operates only with sub-optimal parameters (few coarse quantization centroids). Many other methods, like LOPQ and the Polyseymous codes [27, 16] are too complex to be implemented efficiently on GPUs.\n' +
      '\n' +
      'There are many implementations of similarity search on GPUs, but mostly with binary codes [36], small datasets [44], or exhaustive search [14, 40, 41]. To the best of our knowledge, only the work by Wieschollek et al. [47] appears suitable for billion-scale datasets with quantization codes. This is the prior state of the art on GPUs, which we compare against in Section 6.4.\n' +
      '\n' +
      'This paper makes the following contributions:\n' +
      '\n' +
      '* a GPU \\(k\\)-selection algorithm, operating in fast register memory and flexible enough to be fusable with other kernels, for which we provide a complexity analysis;\n' +
      '* a near-optimal algorithmic layout for exact and approximate \\(k\\)-nearest neighbor search on GPU;\n' +
      '* a range of experiments that show that these improvements outperform previous art by a large margin on mid- to large-scale nearest-neighbor search tasks, in single or multi-GPU configurations.\n' +
      '\n' +
      'The paper is organized as follows. Section 2 introduces the context and notation. Section 3 reviews GPU architecture and discusses problems appearing when using it for similarity search. Section 4 introduces one of our main contributions, _i.e._, our k-selection method for GPUs, while Section 5 provides details regarding the algorithm computation layout. Finally, Section 6 provides extensive experiments for our approach, compares it to the state of the art, and shows concrete use cases for image collections.\n' +
      '\n' +
      '## 2 Problem Statement\n' +
      '\n' +
      'We are concerned with similarity search in vector collections. Given the query vector \\(x\\in\\mathbb{R}^{d}\\) and the collection2\\([y_{i}]_{i=0:\\ell}\\) (\\(y_{i}\\in\\mathbb{R}^{d}\\)), we search:\n' +
      '\n' +
      'Footnote 2: To avoid clutter in 0-based indexing, we use the array notation \\(0:\\ell\\) to denote the range \\(\\{0,...,\\ell-1\\}\\) inclusive.\n' +
      '\n' +
      '\\[L=k\\text{-}\\text{argmin}_{i=0:\\ell}\\|x-y_{i}\\|_{2}, \\tag{1}\\]\n' +
      '\n' +
      '_i.e._, we search the \\(k\\) nearest neighbors of \\(x\\) in terms of L2 distance. The L2 distance is used most often, as it is optimized by design when learning several embeddings (_e.g._, [20]), due to its attractive linear algebra properties.\n' +
      '\n' +
      'The lowest distances are collected by \\(k\\)-selection. For an array \\([a_{i}]_{i=0:\\ell}\\), \\(k\\)-selection finds the \\(k\\) lowest valued elements \\([a_{s_{i}}]_{i=0:k}\\), \\(a_{s_{i}}\\leq a_{s_{i+1}}\\), along with the indices \\([s_{i}]_{i=0:k}\\), \\(0\\leq s_{i}<\\ell\\), of those elements from the input array. The \\(a_{i}\\) will be 32-bit floating point values; the \\(s_{i}\\) are 32- or 64-bit integers. Other comparators are sometimes desired; _e.g._, for cosine similarity we search for _highest_ values. The order between equivalent keys \\(a_{s_{i}}=a_{s_{j}}\\) is not specified.\n' +
      '\n' +
      '**Batching.** Typically, searches are performed in batches of \\(n_{\\text{q}}\\) query vectors \\([x_{j}]_{j=0:n_{\\text{q}}}\\) (\\(x_{j}\\in\\mathbb{R}^{d}\\)) in parallel, which allows for more flexibility when executing on multiple CPU threads or on GPU. Batching for \\(k\\)-selection entails selecting \\(n_{\\text{q}}\\times k\\) elements and indices from \\(n_{\\text{q}}\\) separate arrays, where each array is of a potentially different length \\(\\ell_{i}\\geq k\\).\n' +
      '\n' +
      '**Exact search.** The exact solution computes the full pairwise distance matrix \\(D=[\\|x_{j}-y_{i}\\|_{2}^{2}]_{j=0:n_{\\text{q}},i=0:\\ell}\\in\\mathbb{R}^{n_{\\text {q}}\\times\\ell}\\). In practice, we use the decomposition\n' +
      '\n' +
      '\\[\\|x_{j}-y_{i}\\|_{2}^{2}=\\|x_{j}\\|^{2}+\\|y_{i}\\|^{2}-2\\langle x_{j},y_{i}\\rangle. \\tag{2}\\]\n' +
      '\n' +
      'The two first terms can be precomputed in one pass over the matrices \\(X\\) and \\(Y\\) whose rows are the \\([x_{j}]\\) and \\([y_{i}]\\). The bottleneck is to evaluate \\(\\langle x_{j},y_{i}\\rangle\\), equivalent to the matrix multiplication \\(XY^{\\top}\\). The \\(k\\)-nearest neighbors for each of the \\(n_{\\text{q}}\\) queries are \\(k\\)-selected along each row of \\(D\\).\n' +
      '\n' +
      '**Compressed-domain search.** From now on, we focus on approximate nearest-neighbor search. We consider, in particular, the _IVFADC_ indexing structure [25]. The IVFADC index relies on two levels of quantization, and the database vectors are encoded. The database vector \\(y\\) is approximated as:\n' +
      '\n' +
      '\\[y\\approx q(y)=q_{1}(y)+q_{2}(y-q_{1}(y)) \\tag{3}\\]\n' +
      '\n' +
      'where \\(q_{1}:\\mathbb{R}^{d}\\to\\mathcal{C}_{1}\\subset\\mathbb{R}^{d}\\) and \\(q_{2}:\\mathbb{R}^{d}\\to\\mathcal{C}_{2}\\subset\\mathbb{R}^{d}\\) are quantizers; _i.e._, functions that output an element from a finite set. Since the sets are finite, \\(q(y)\\) is encoded as the index of \\(q_{1}(y)\\) and that of \\(q_{2}(y-q_{1}(y))\\). The first-level quantizer is a _coarse quantizer_ and the second level _fine quantizer_ encodes the residual vector after the first level.\n' +
      '\n' +
      'The Asymmetric Distance Computation (ADC) search method returns an approximate result:\n' +
      '\n' +
      '\\[L_{\\text{ADC}}=k\\text{-}\\text{argmin}_{i=0:\\ell}\\|x-q(y_{i})\\|_{2}. \\tag{4}\\]\n' +
      '\n' +
      'For IVFADC the search is not exhaustive. Vectors for which the distance is computed are pre-selected depending on the first-level quantizer \\(q_{1}\\):\n' +
      '\n' +
      '\\[L_{\\text{IVF}}=\\tau\\text{-}\\text{argmin}_{c\\in\\mathcal{C}_{1}}\\|x-c\\|_{2}. \\tag{5}\\]\n' +
      '\n' +
      'The _multi-probe parameter_\\(\\tau\\) is the number of coarse-level centroids we consider. The quantizer operates a nearest-neighbor search with exact distances, in the set of reproduction values. Then, the IVFADC search computes\n' +
      '\n' +
      '\\[L_{\\text{IVFADC}}=\\underset{i=0:\\ell\\text{ s.t. }q_{1}(y_{i})\\in L_{\\text{IVF}}}{k \\text{-}\\text{argmin}}\\|x-q(y_{i})\\|_{2}. \\tag{6}\\]\n' +
      '\n' +
      'Hence, IVFADC relies on the same distance estimations as the two-step quantization of ADC, but computes them only on a subset of vectors.\n' +
      '\n' +
      'The corresponding data structure, the _inverted file_, groups the vectors \\(y_{i}\\) into \\(|\\mathcal{C}_{1}|\\)_inverted lists_\\(\\mathcal{I}_{1},...,\\mathcal{I}_{\\mathcal{C}_{1}|}\\) with homogeneous \\(q_{1}(y_{i})\\). Therefore, the most memory-intensive operation is computing \\(L_{\\text{IVFADC}}\\), and boils down to linearly scanning \\(\\tau\\) inverted lists.\n' +
      '\n' +
      '**The quantizers.** The quantizers \\(q_{1}\\) and \\(q_{2}\\) have different properties. \\(q_{1}\\) needs to have a relatively low number of reproduction values so that the number of inverted lists does not explode. We typically use \\(|C_{1}|\\approx\\sqrt{t}\\), trained via \\(k\\)-means. For \\(q_{2}\\), we can afford to spend more memory for a more extensive representation. The ID of the vector (a - or 8-byte integer) is also stored in the inverted lists, so it makes no sense to have shorter codes than that; _i.e._, \\(\\log_{2}|\\mathcal{C}_{2}|>4\\times 8\\).\n' +
      '\n' +
      '**Product quantizer.** We use a _product quantizer_[25] for \\(q_{2}\\), which provides a large number of reproduction values without increasing the processing cost. It interprets the vector \\(y\\) as \\(b\\) sub-vectors \\(y=[y^{0}...y^{b-1}]\\), where \\(b\\) is an even divisor of the dimension \\(d\\). Each sub-vector is quantized with its own quantizer, yielding the tuple (\\(q^{0}(y^{0})\\),..., \\(q^{b-1}(y^{b-1})\\)). The sub-quantizers typically have 256 reproduction values, to fit in one byte. The quantization value of the product quantizer is then \\(q_{2}(y)=q^{0}(y^{0})+256\\times q^{1}(y^{1})+...+256^{b-1}\\times q^{b-1}\\), which from a storage point of view is just the concatenation of the bytes produced by each sub-quantizer. Thus, the product quantizer generates \\(b\\)-byte codes with \\(|\\mathcal{C}_{2}|=256^{b}\\) reproduction values. The \\(k\\)-means dictionaries of the quantizers are small and quantization is computationally cheap.\n' +
      '\n' +
      '## 3 GPU: Overview and K-selection\n' +
      '\n' +
      'This section reviews salient details of Nvidia\'s general-purpose GPU architecture and programming model [30]. We then focus on one of the less GPU-compliant parts involved in similarity search, namely the \\(k\\)-selection, and discuss the literature and challenges.\n' +
      '\n' +
      '### Architecture\n' +
      '\n' +
      '**GPU lanes and warps.** The Nvidia GPU is a general-purpose computer that executes instruction streams using a 32-wide vector of _CUDA threads_ (the _warp_); individual threads in the warp are referred to as _lanes_, with a _lane ID_ from 0 - 31. Despite the "thread" terminology, the best analogy to modern vectorized multicore CPUs is that each warp is a separate CPU hardware thread, as the warp shares an instruction counter. Warp lanes taking different execution paths results in _warp divergence_, reducing performance. Each lane has up to 255 32-bit registers in a shared register file. The CPU analogy is that there are up to 255 vector registers of width 32, with warp lanes as SIMD vector lanes.\n' +
      '\n' +
      '**Collections of warps.** A user-configurable collection of 1 to 32 warps comprises a _block_ or a _co-operative thread array_ (CTA). Each block has a high speed _shared memory_, up to 48 KiB in size. Individual CUDA threads have a block-relative ID, called a _thread id_, which can be used to partition and assign work. Each block is run on a single core of the GPU called a _streaming multiprocessor_ (SM). Each SM has _functional units_, including ALUs, memory load/store units, and various special instruction units. A GPU hides execution latencies by having many operations in flight on warps across all SMs. Each individual warp lane instruction throughput is low and latency is high, but the aggregate arithmetic throughput of all SMs together is 5 - 10\\(\\times\\) higher than typical CPUs.\n' +
      '\n' +
      '**Grids and kernels.** Blocks are organized in a _grid_ of blocks in a _kernel_. Each block is assigned a grid relative ID. The kernel is the unit of work (instruction stream with arguments) scheduled by the host CPU for the GPU to execute. After a block runs through to completion, new blocks can be scheduled. Blocks from different kernels can run concurrently. Ordering between kernels is controllable via ordering primitives such as _streams_ and _events_.\n' +
      '\n' +
      '**Resources and occupancy.** The number of blocks executing concurrently depends upon shared memory and register resources used by each block. Per-CUDA thread register usage is determined at compilation time, while shared memory usage can be chosen at runtime. This usage affects _occupancy_ on the GPU. If a block demands all 48 KiB of shared memory for its private usage, or 128 registers per thread as opposed to 32, then only 1 - 2 other blocks can run concurrently on the same SM, resulting in low occupancy. Under high occupancy more blocks will be present across all SMs, allowing more work to be in flight at once.\n' +
      '\n' +
      '**Memory types.** Different blocks and kernels communicate through _global memory_, typically 4 - 32 GB in size, with 5 - 10\\(\\times\\) higher bandwidth than CPU main memory. Shared memory is analogous to CPU L1 cache in terms of speed. GPU register file memory is the highest bandwidth memory. In order to maintain the high number of instructions in flight on a GPU, a vast register file is also required: 14 MB in the latest Pascal P100, in contrast with a few tens of KB on CPU. A ratio of 250 : 6.25 : 1 for register to shared to global memory aggregate cross-sectional bandwidth is typical on GPU, yielding 10 - 100s of TB/s for the register file [10].\n' +
      '\n' +
      '### GPU register file usage\n' +
      '\n' +
      '**Structured register data.** Shared and register memory usage involves efficiency tradeoffs; they lower occupancy but can increase overall performance by retaining a larger working set in a faster memory. Making heavy use of register-resident data at the expense of occupancy or instead of shared memory is often profitable [43].\n' +
      '\n' +
      'As the GPU register file is very large, storing structured data (not just temporary operands) is useful. A single lane can use its (scalar) registers to solve a local task, but with limited parallelism and storage. Instead, lanes in a GPU warp can instead exchange register data using the _warp shuffle_ instruction, enabling warp-wide parallelism and storage.\n' +
      '\n' +
      '**Lane-stride register array.** A common pattern to achieve this is a _lane-stride register array_. That is, given elements \\([a_{i}]_{i=0:\\ell}\\), each successive value is held in a register by neighboring lanes. The array is stored in \\(\\ell/32\\) registers per lane, with \\(\\ell\\) a multiple of 32. Lane \\(j\\) stores \\(\\{a_{j},a_{32+j},...,a_{\\ell-32+j}\\}\\), while register \\(r\\) holds \\(\\{a_{32r},a_{32r+1},...,a_{32r+31}\\}\\).\n' +
      '\n' +
      'For manipulating the \\([a_{i}]\\), the register in which \\(a_{i}\\) is stored (_i.e., \\(\\lfloor i/32\\rfloor\\)_) and \\(\\ell\\) must be known at assembly time, while the lane (_i.e., i_ mod 32) can be runtime knowledge. A wide variety of access patterns (shift, any-to-any) are provided; we use the butterfly permutation [29] extensively.\n' +
      '\n' +
      '### k-selection on CPU versus GPU\n' +
      '\n' +
      '\\(k\\)-selection algorithms, often for arbitrarily large \\(\\ell\\) and \\(k\\), can be translated to a GPU, including _radix selection_ and _bucket selection_[1], _probabilistic selection_[33], _quickselect_[14], and _truncated sorts_[40]. Their performance is dominated by multiple passes over the input in global memory. Sometimes for similarity search, the input distances are computed on-the-fly or stored only in small blocks, not in their entirety. The full, explicit array might be too large to fit into any memory, and its size could be unknown at the start of the processing, rendering algorithms that require multiple passes impractical. They suffer from other issues as well. Quickselect requires partitioning on a storage of size \\(\\mathcal{O}(\\ell)\\), a data-dependent memory movement. This can result in excessive memory transactions, or requiring parallel prefix sums to determine write offsets, with synchronization overhead. Radix selection has no partitioning but multiple passes are still required.\n' +
      '\n' +
      '**Heap parallelism.** In similarity search applications, one is usually interested only in a small number of results,1000 or so. In this regime, selection via max-heap is a typical choice on the CPU, but heaps do not expose much data parallelism (due to serial tree update) and cannot saturate SIMD execution units. The _ad-heap_[31] takes better advantage of parallelism available in heterogeneous systems, but still attempts to partition serial and parallel work between appropriate execution units. Despite the serial nature of heap update, for small \\(k\\) the CPU can maintain all of its state in the L1 cache with little effort, and L1 cache latency and bandwidth remains a limiting factor. Other similarity search components, like PQ code manipulation, tend to have greater impact on CPU performance [2].\n' +
      '\n' +
      '**GPU heaps.** Heaps can be similarly implemented on a GPU [7]. However, a straightforward GPU heap implementation suffers from high warp divergence and irregular, data-dependent memory movement, since the path taken for each inserted element depends upon other values in the heap.\n' +
      '\n' +
      'GPU parallel priority queues [24] improve over the serial heap update by allowing multiple concurrent updates, but they require a potential number of small sorts for each insert and data-dependent memory movement. Moreover, it uses multiple synchronization barriers through kernel launches in different streams, plus the additional latency of successive kernel launches and coordination with the CPU host.\n' +
      '\n' +
      'Other more novel GPU algorithms are available for small \\(k\\), namely the selection algorithm in the _fgknn_ library [41]. This is a complex algorithm that may suffer from too many synchronization points, greater kernel launch overhead, usage of slower memories, excessive use of hierarchy, partitioning and buffering. However, we take inspiration from this particular algorithm through the use of parallel merges as seen in their _merge queue_ structure.\n' +
      '\n' +
      '## 4 Fast K-selection on the GPU\n' +
      '\n' +
      'For any CPU or GPU algorithm, either memory or arithmetic throughput should be the limiting factor as per the _roofline performance model_[48]. For input from global memory, \\(k\\)-selection cannot run faster than the time required to scan the input once at peak memory bandwidth. We aim to get as close to this limit as possible. Thus, we wish to perform a single pass over the input data (from global memory or produced on-the-fly, perhaps fused with a kernel that is generating the data).\n' +
      '\n' +
      'We want to keep intermediate state in the fastest memory: the register file. The major disadvantage of register memory is that the indexing into the register file must be known at assembly time, which is a strong constraint on the algorithm.\n' +
      '\n' +
      '### In-register sorting\n' +
      '\n' +
      'We use an in-register sorting primitive as a building block. Sorting networks are commonly used on SIMD architectures [13], as they exploit vector parallelism. They are easily implemented on the GPU, and we build sorting networks with lane-stride register arrays.\n' +
      '\n' +
      'We use a variant of _Batcher\'s bitonic sorting network_[8], which is a set of parallel merges on an array of size \\(2^{k}\\). Each merge takes \\(s\\) arrays of length \\(t\\) (\\(s\\) and \\(t\\) a power of 2) to \\(s/2\\) arrays of length \\(2t\\), using \\(\\log_{2}(t)\\) parallel steps. A bitonic sort applies this merge recursively: to sort an array of length \\(\\ell\\), merge \\(\\ell\\) arrays of length 1 to \\(\\ell/2\\) arrays of length 2, to \\(\\ell/4\\) arrays of length 4, successively to 1 sorted array of length \\(\\ell\\), leading to \\(\\frac{1}{2}(\\log_{2}(\\ell)^{2}+\\log_{2}(\\ell))\\) parallel merge steps.\n' +
      '\n' +
      '**Odd-size merging and sorting networks.** If some input data is already sorted, we can modify the network to avoid merging steps. We may also not have a full power-of-2 set of data, in which case we can efficiently shortcut to deal with the smaller size.\n' +
      '\n' +
      'Algorithm 1 is an odd-sized merging network that merges already sorted _left_ and _right_ arrays, each of arbitrary length. While the bitonic network merges _bitonic_ sequences, we start with _monotonic_ sequences: sequences sorted monotonically. A bitonic merge is made monotonic by reversing the first comparator stage.\n' +
      '\n' +
      '```\n' +
      'functionmerge-odd(\\([L_{i}]_{i=0:\\ell_{L}},[R_{i}]_{i=0:\\ell_{R}}\\)) parallelfor\\(i\\gets 0:\\min(\\ell_{L},\\ell_{R})\\)do\\(\\triangleright\\) inverted 1st stage; inputs are already sorted compare-swap(\\(L_{\\ell_{L}-i-1},R_{i}\\)) endfor paralleldo\\(\\triangleright\\) If \\(\\ell_{L}=\\ell_{R}\\) and a power-of-2, these are equivalent merge-odd-continue(\\([L_{i}]_{i=0:\\ell_{L}}\\), left) merge-odd-continue(\\([R_{i}]_{i=0:\\ell_{R}}\\), right) enddo endfunctionfunctionmerge-odd-continue(\\([x_{i}]_{i=0:\\ell},p\\)) if\\(\\ell>1\\)then\\(h\\gets 2^{\\lceil\\log_{2}\\ell\\rceil-1}\\)\\(\\triangleright\\) largest power-of-\\(2<\\ell\\) parallelfor\\(i\\gets 0:\\ell-h\\)do\\(\\triangleright\\) Implemented with warp shuffle butterfly compare-swap(\\(x_{i},x_{i+h}\\)) endfor paralleldo if\\(p=\\)leftthen\\(\\triangleright\\) left side recursion merge-odd-continue(\\([x_{i}]_{i=0:\\ell-h},\\)left) merge-odd-continue(\\([x_{i}]_{i=t-h:\\ell},\\)right) else merge-odd-continue(\\([x_{i}]_{i=0:h},\\)left) merge-odd-continue(\\([x_{i}]_{i=h:\\ell},\\)right) endif enddo endif endfunction\n' +
      '```\n' +
      '\n' +
      '**Algorithm 1** Odd-size merging network\n' +
      '\n' +
      'The odd size algorithm is derived by considering arrays to be padded to the next highest power-of-2 size with dummy\n' +
      '\n' +
      'Figure 1: Odd-size network merging arrays of sizes 5 and 3. Bullets indicate parallel compare/swap. Dashed lines are elided elements or comparisons.\n' +
      '\n' +
      'elements that are never swapped (the merge is monotonic) and are already properly positioned; any comparisons with dummy elements are elided. A left array is considered to be padded with dummy elements at the start; a right array has them at the end. A merge of two sorted arrays of length \\(\\ell_{L}\\) and \\(\\ell_{R}\\) to a sorted array of \\(\\ell_{L}+\\ell_{R}\\) requires \\(\\lceil\\log_{2}(\\max(\\ell_{L},\\ell_{R}))\\rceil+1\\) parallel steps. Figure 1 shows Algorithm 1\'s merging network for arrays of size 5 and 3, with 4 parallel steps.\n' +
      '\n' +
      'The compare-swap is implemented using warp shuffles on a lane-stride register array. Swaps with a stride a multiple of 32 occur directly within a lane as the lane holds both elements locally. Swaps of stride \\(\\leq 16\\) or a non-multiple of 32 occur with warp shuffles. In practice, used array lengths are multiples of 32 as they are held in lane-stride arrays.\n' +
      '\n' +
      '```\n' +
      'function sort-odd(\\([x_{i}]_{i=0:t}\\)) if\\(\\ell>1\\)then parallel do  sort-odd(\\([x_{i}]_{i=0:\\lfloor\\ell/2\\rfloor}\\))  sort-odd(\\([x_{i}]_{i=\\lfloor\\ell/2\\rfloor:t}\\))  end do  merge-odd(\\([x_{i}]_{i=0:\\lfloor\\ell/2\\rfloor},[x_{i}]_{i=\\lfloor\\ell/2\\rfloor:t}\\)) endif endfunction\n' +
      '```\n' +
      '\n' +
      '**Algorithm 2** Odd-size sorting network\n' +
      '\n' +
      'Algorithm 2 extends the merge to a full sort. Assuming no structure present in the input data, \\(\\frac{1}{2}(\\lceil\\log_{2}(\\ell)\\rceil^{2}+\\lceil\\log_{2}(\\ell)\\rceil)\\) parallel steps are required for sorting data of length \\(\\ell\\).\n' +
      '\n' +
      '### WarpSelect\n' +
      '\n' +
      'Our \\(k\\)-selection implementation, WarpSelect, maintains state entirely in registers, requires only a single pass over data and avoids cross-warp synchronization. It uses merge-odd and sort-odd as primitives. Since the register file provides much more storage than shared memory, it supports \\(k\\leq 1024\\). Each warp is dedicated to \\(k\\)-selection to a single one of the \\(n\\) arrays \\([a_{i}]\\). If \\(n\\) is large enough, a single warp per each \\([a_{i}]\\) will result in full GPU occupancy. Large \\(\\ell\\) per warp is handled by recursive decomposition, if \\(\\ell\\) is known in advance.\n' +
      '\n' +
      '**Overview.** Our approach (Algorithm 3 and Figure 2) operates on values, with associated indices carried along (omitted from the description for simplicity). It selects the \\(k\\) least values that come from global memory, or from intermediate value registers if fused into another kernel providing the values. Let \\([a_{i}]_{i=0:\\ell}\\) be the sequence provided for selection.\n' +
      '\n' +
      'The elements (on the left of Figure 2) are processed in groups of 32, the warp size. Lane \\(j\\) is responsible for processing \\(\\{a_{j},a_{32+j},...\\}\\); thus, if the elements come from global memory, the reads are contiguous and coalesced into a minimal number of memory transactions.\n' +
      '\n' +
      '**Data structures.** Each lane \\(j\\) maintains a small queue of \\(t\\) elements in registers, called the _thread queues_\\([T_{i}^{j}]_{i=0:t}\\), ordered from largest to smallest (\\(T_{i}^{j}\\geq T_{i+1}^{j}\\)). The choice of \\(t\\) is made relative to \\(k\\), see Section 4.3. The thread queue is a first-level filter for new values coming. In f. a new \\(a_{32i+j}\\) is greater than the largest key currently in the queue, \\(T_{0}^{j}\\), it is guaranteed that it won\'t be in the \\(k\\) smallest final results.\n' +
      '\n' +
      'The warp shares a lane-stride register array of \\(k\\) smallest seen elements, \\([W_{i}]_{i=0:k}\\), called the _warp queue_. It is ordered from smallest to largest (\\(W_{i}\\leq W_{i+1}\\)); if the requested \\(k\\) is not a multiple of 32, we round it up. This is a second level data structure that will be used to maintain all of the \\(k\\) smallest warp-wide seen values. The thread and warp queues are initialized to maximum sentinel values, _e.g._, \\(+\\infty\\).\n' +
      '\n' +
      '**Update.** The three invariants maintained are:\n' +
      '\n' +
      '* all per-lane \\(T_{0}^{j}\\) are not in the min-\\(k\\)\n' +
      '* all per-lane \\(T_{0}^{j}\\) are greater than all warp queue keys \\(W_{i}\\)\n' +
      '* all \\(a_{i}\\) seen so far in the min-\\(k\\) are contained in either some lane\'s thread queue (\\([T_{i}^{j}]_{i=0:t,j=0:32}\\)), or in the warp queue.\n' +
      '\n' +
      'Lane \\(j\\) receives a new \\(a_{32i+j}\\) and attempts to insert it into its thread queue. If \\(a_{32i+j}>T_{0}^{j}\\), then the new pair is by definition not in the \\(k\\) minimum, and can be rejected.\n' +
      '\n' +
      'Otherwise, it is inserted into its proper sorted position in the thread queue, thus ejecting the old \\(T_{0}^{j}\\). All lanes complete doing this with their new received pair and their thread queue, but it is now possible that the second invariant have been violated. Using the _warp ballot_ instruction, we determine if any lane has violated the second invariant. If not, we are free to continue processing new elements.\n' +
      '\n' +
      '**Restoring the invariants.** If any lane has its invariant violated, then the warp uses odd-merge to merge and sort the thread and warp queues together. The new warp queue\n' +
      '\n' +
      '```\n' +
      'function WarpSelect(\\(a\\)) if\\(a<T_{0}^{j}\\)then insert \\(a\\) into our \\([T_{i}^{j}]_{i=0:t}\\) endif if\\(\\textsc{warp-ballot}(T_{0}^{j}<W_{k-1})\\)then \\(\\triangleright\\) Reinterpret thread queues as lane-stride array \\([\\alpha_{i}]_{i=0:32t}\\leftarrow\\textsc{cast}([T_{i}^{j}]_{i=0:t,j=0:32})\\) \\(\\triangleright\\) concatenate and sort thread queues \\(\\textsc{sort-odd}([\\alpha_{i}]_{i=0:32t})\\)  merge-odd(\\([W_{i}]_{i=0:k},[\\alpha_{i}]_{i=0:32t})\\) \\(\\triangleright\\) Reinterpret thread-stride array as thread queues \\([T_{i}^{j}]_{i=0:t,j=0:32}\\leftarrow\\textsc{cast}([\\alpha_{i}]_{i=0:32t})\\)  reverse-array(\\([T_{i}]_{i=0:t})\\) \\(\\triangleright\\) Back in thread queue order, invariant restored endif endfunction\n' +
      '```\n' +
      '\n' +
      '**Algorithm 3** WarpSelect pseudocode for lane \\(j\\)\n' +
      '\n' +
      'Figure 2: Overview of WarpSelect. The input values stream in on the left, and the warp queue on the right holds the output result.\n' +
      '\n' +
      'will be the min-\\(k\\) elements across the merged, sorted queues, and the new thread queues will be the remainder, from min-\\((k+1)\\) to min-\\((k+32t+1)\\). This restores the invariants and we are free to continue processing subsequent elements.\n' +
      '\n' +
      'Since the thread and warp queues are already sorted, we merge the sorted warp queue of length \\(k\\) with 32 sorted arrays of length \\(t\\). Supporting odd-sized merges is important because Batcher\'s formulation would require that \\(32t=k\\) and is a power-of-2; thus if \\(k=1024\\), \\(t\\) must be 32. We found that the optimal \\(t\\) is way smaller (see below).\n' +
      '\n' +
      'Using odd-merge to merge the 32 already sorted thread queues would require a _struct-of-arrays_ to _array-of-structs_ transposition in registers across the warp, since the \\(t\\) successive sorted values are held in different registers in the same lane rather than a lane-stride array. This is possible [12], but would use a comparable number of warp shuffles, so we just reinterpret the thread queue registers as an (unsorted) lane-stride array and sort from scratch. Significant speedup is realizable by using odd-merge for the merge of the aggregate sorted thread queues with the warp queue.\n' +
      '\n' +
      '**Handling the remainder.** If there are remainder elements because \\(\\ell\\) is not a multiple of 32, those are inserted into the thread queues for the lanes that have them, after which we proceed to the output stage.\n' +
      '\n' +
      '**Output.** A final sort and merge is made of the thread and warp queues, after which the warp queue holds all min-\\(k\\) values.\n' +
      '\n' +
      '### Complexity and parameter selection\n' +
      '\n' +
      'For each incoming group of 32 elements, WarpSelect can perform 1, 2 or 3 constant-time operations, all happening in warp-wide parallel time:\n' +
      '\n' +
      '1. read 32 elements, compare to all thread queue heads \\(T_{0}^{j}\\), cost \\(C_{1}\\), happens \\(N_{1}\\) times;\n' +
      '2. if \\(\\exists j\\in\\{0,...,31\\}\\), \\(a_{32n+j}<T_{0}^{j}\\), perform insertion sort on those specific thread queues, cost \\(C_{2}=\\mathcal{O}(t)\\), happens \\(N_{2}\\) times;\n' +
      '3. if \\(\\exists j,T_{0}^{j}<W_{k-1}\\), sort and merge queues, cost \\(C_{3}=\\mathcal{O}(t\\log(32t)^{2}+k\\log(\\max(k,32t)))\\), happens \\(N_{3}\\) times.\n' +
      '\n' +
      'Thus, the total cost is \\(N_{1}C_{1}+N_{2}C_{2}+N_{3}C_{3}\\). \\(N_{1}=\\ell/32\\), and on random data drawn independently, \\(N_{2}=\\mathcal{O}(k\\log(\\ell))\\) and \\(N_{3}=\\mathcal{O}(k\\log(\\ell)/t)\\), see the Appendix for a full derivation. Hence, the trade-off is to balance a cost in \\(N_{2}C_{2}\\) and one in \\(N_{3}C_{3}\\). The practical choice for \\(t\\) given \\(k\\) and \\(\\ell\\) was made by experiment on a variety of \\(k\\)-NN data. For \\(k\\leq 32\\), we use \\(t=2\\), \\(k\\leq 128\\) uses \\(t=3\\), \\(k\\leq 256\\) uses \\(t=4\\), and \\(k\\leq 1024\\) uses \\(t=8\\), all irrespective of \\(\\ell\\).\n' +
      '\n' +
      '## 5 Computation Layout\n' +
      '\n' +
      'This section explains how IVFADC, one of the indexing methods originally built upon product quantization [25], is implemented efficiently. Details on distance computations and articulation with \\(k\\)-selection are the key to understanding why this method can outperform more recent GPU-compliant approximate nearest neighbor strategies [47].\n' +
      '\n' +
      '### Exact search\n' +
      '\n' +
      'We briefly come back to the exhaustive search method, often referred to as exact brute-force. It is interesting on its own for exact nearest neighbor search in small datasets. It is also a component of many indexes in the literature. In our case, we use it for the IVFADC coarse quantizer \\(q_{1}\\).\n' +
      '\n' +
      'As stated in Section 2, the distance computation boils down to a matrix multiplication. We use optimized GEMM routines in the cuBLAS library to calculate the \\(-2\\langle x_{j},y_{i}\\rangle\\) term for L2 distance, resulting in a partial distance matrix \\(D^{\\prime}\\). To complete the distance calculation, we use a fused \\(k\\)-selection kernel that adds the \\(\\|y_{i}\\|^{2}\\) term to each entry of the distance matrix and immediately submits the value to \\(k\\)-selection in registers. The \\(\\|x_{j}\\|^{2}\\) term need not be taken into account before \\(k\\)-selection. Kernel fusion thus allows for only 2 passes (GEMM write, \\(k\\)-select read) over \\(D^{\\prime}\\), compared to other implementations that may require 3 or more. Row-wise \\(k\\)-selection is likely not fusable with a well-tuned GEMM kernel, or would result in lower overall efficiency.\n' +
      '\n' +
      'As \\(D^{\\prime}\\) does not fit in GPU memory for realistic problem sizes, the problem is tiled over the batch of queries, with \\(t_{q}\\leq n_{q}\\) queries being run in a single tile. Each of the \\(\\lceil n_{q}/t_{q}\\rceil\\) tiles are independent problems, but we run two in parallel on different streams to better occupy the GPU, so the effective memory requirement of \\(D\\) is \\(\\mathcal{O}(2\\ell t_{q})\\). The computation can similarly be tiled over \\(\\ell\\). For very large input coming from the CPU, we support buffering with pinned memory to overlap CPU to GPU copy with GPU compute.\n' +
      '\n' +
      '### IVFADC indexing\n' +
      '\n' +
      '**PQ lookup tables.** At its core, the IVFADC requires computing the distance from a vector to a set of product quantization reproduction values. By developing Equation (6) for a database vector \\(y\\), we obtain:\n' +
      '\n' +
      '\\[\\|x-q(y)\\|_{2}^{2}=\\|x-q_{1}(y)-q_{2}(y-q_{1}(y))\\|_{2}^{2}. \\tag{7}\\]\n' +
      '\n' +
      'If we decompose the residual vectors left after \\(q_{1}\\) as:\n' +
      '\n' +
      '\\[y-q_{1}(y) = [\\widetilde{y^{1}}\\cdots\\widetilde{y^{b}}]\\text{ and } \\tag{8}\\] \\[x-q_{1}(y) = [\\widetilde{x^{1}}\\cdots\\widetilde{x^{b}}] \\tag{9}\\]\n' +
      '\n' +
      'then the distance is rewritten as:\n' +
      '\n' +
      '\\[\\|x-q(y)\\|_{2}^{2}=\\|\\widetilde{x^{1}}-q^{1}(\\widetilde{y^{1}})\\|_{2}^{2}+...+ \\|\\widetilde{x^{b}}-q^{b}(\\widetilde{y^{b}})\\|_{2}^{2}. \\tag{10}\\]\n' +
      '\n' +
      'Each quantizer \\(q^{1},...,q^{b}\\) has 256 reproduction values, so when \\(x\\) and \\(q_{1}(y)\\) are known all distances can be precomputed and stored in tables \\(T_{1},...,T_{b}\\) each of size 256 [25]. Computing the sum (10) consists of \\(b\\) look-ups and additions. Comparing the cost to compute \\(n\\) distances:\n' +
      '\n' +
      '* Explicit computation: \\(n\\times d\\) multiply-adds;\n' +
      '* With lookup tables: \\(256\\times d\\) multiply-adds and \\(n\\times b\\) lookup-adds.\n' +
      '\n' +
      'This is the key to the efficiency of the product quantizer. In our GPU implementation, \\(b\\) is any multiple of 4 up to 64. The codes are stored as sequential groups of \\(b\\) bytes per vector within lists.\n' +
      '\n' +
      '**IVFADC lookup tables.** When scanning over the elements of the inverted list \\(\\mathcal{I}_{L}\\) (where by definition \\(q_{1}(y)\\) is constant), the look-up table method can be applied, as the query \\(x\\) and \\(q_{1}(y)\\) are known.\n' +
      '\n' +
      'Moreover, the computation of the tables \\(T_{1}\\ldots T_{b}\\) is further optimized [5]. The expression of \\(\\|x-q(y)\\|_{2}^{2}\\) in Equation (7) can be decomposed as:\n' +
      '\n' +
      '\\[\\underbrace{\\|q_{2}(...)\\|_{2}^{2}+2\\langle q_{1}(y),q_{2}(...)\\rangle}_{\\text {term 1}}+\\underbrace{\\|x-q_{1}(y)\\|_{2}^{2}}_{\\text{term 2}}-2\\underbrace{\\langle x,q_{2}(...)\\rangle}_{\\text{term 3}}. \\tag{11}\\]\n' +
      '\n' +
      'The objective is to minimize inner loop computations. The computations we can do in advance and store in lookup tables are as follows:\n' +
      '\n' +
      '* Term 1 is independent of the query. It can be precomputed from the quantizers, and stored in a table \\(\\mathcal{T}\\) of size \\(|\\mathcal{C}_{1}|\\times 256\\times b\\);\n' +
      '* Term 2 is the distance to \\(q_{1}\\)\'s reproduction value. It is thus a by-product of the first-level quantizer \\(q_{1}\\);\n' +
      '* Term 3 can be computed independently of the inverted list. Its computation costs \\(d\\times 256\\) multiply-adds.\n' +
      '\n' +
      'This decomposition is used to produce the lookup tables \\(T_{1}\\ldots T_{b}\\) used during the scan of the inverted list. For a single query, computing the \\(\\tau\\times b\\) tables from scratch costs \\(\\tau\\times d\\times 256\\) multiply-adds, while this decomposition costs \\(256\\times d\\) multiply-adds and \\(\\tau\\times b\\times 256\\) additions. On the GPU, the memory usage of \\(\\mathcal{T}\\) can be prohibitive, so we enable the decomposition only when memory is a not a concern.\n' +
      '\n' +
      '### GPU implementation\n' +
      '\n' +
      'Algorithm 4 summarizes the process as one would implement it on a CPU. The inverted lists are stored as two separate arrays, for PQ codes and associated IDs. IDs are resolved only if \\(k\\)-selection determines \\(k\\)-nearest membership. This lookup yields a few sparse memory reads in a large array, thus the IDs can optionally be stored on CPU for tiny performance cost.\n' +
      '\n' +
      '**List scanning.** A kernel is responsible for scanning the \\(\\tau\\) closest inverted lists for each query, and calculating the per-vector pair distances using the lookup tables \\(T_{i}\\). The \\(T_{i}\\) are stored in shared memory: up to \\(n_{q}\\times\\tau\\times\\max_{i}|\\mathcal{I}_{i}|\\times b\\) lookups are required for a query set (trillions of accesses in practice), and are random access. This limits \\(b\\) to at most 48 (32-bit floating point) or 96 (16-bit floating point) with current architectures. In case we do not use the decomposition of Equation (11), the \\(T_{i}\\) are calculated by a separate kernel before scanning.\n' +
      '\n' +
      '**Multi-pass kernels.** Each \\(n_{q}\\times\\tau\\) pairs of query against inverted list can be processed independently. At one extreme, a block is dedicated to each of these, resulting in up to \\(n_{q}\\times\\tau\\times\\max_{i}|\\mathcal{I}_{i}|\\) partial results being written back to global memory, which is then \\(k\\)-selected to \\(n_{q}\\times k\\) final results. This yields high parallelism but can exceed available GPU global memory; as with exact search, we choose a tile size \\(t_{q}\\leq n_{q}\\) to reduce memory consumption, bounding its complexity by \\(\\mathcal{O}(2t_{q}\\tau\\max_{i}|\\mathcal{I}_{i}|)\\) with multi-streaming.\n' +
      '\n' +
      'A single warp could be dedicated to \\(k\\)-selection of each \\(t_{q}\\) set of lists, which could result in low parallelism. We introduce a two-pass \\(k\\)-selection, reducing \\(t_{q}\\times\\tau\\times\\max_{i}|\\mathcal{I}_{i}|\\) to \\(t_{q}\\times f\\times k\\) partial results for some subdivision factor \\(f\\). This is reduced again via \\(k\\)-selection to the final \\(t_{q}\\times k\\) results.\n' +
      '\n' +
      '**Fused kernel.** As with exact search, we experimented with a kernel that dedicates a single block to scanning all \\(\\tau\\) lists for a single query, with \\(k\\)-selection fused with distance computation. This is possible as WarpSelect does not fight for the shared memory resource which is severely limited. This reduces global memory write-back, since almost all intermediate results can be eliminated. However, unlike \\(k\\)-selection overhead for exact computation, a significant portion of the runtime is the gather from the \\(T_{i}\\) in shared memory and linear scanning of the \\(\\mathcal{I}_{i}\\) from global memory; the write-back is not a dominant contributor. Timing for the fused kernel is improved by at most 15%, and for some problem sizes would be subject to lower parallelism and worse performance without subsequent decomposition. Therefore, and for reasons of implementation simplicity, we do not use this layout.\n' +
      '\n' +
      '```\n' +
      'functionifpPQ-search(\\([x_{1},...,x_{n_{q}}]\\), \\(\\mathcal{I}_{1},...,\\mathcal{I}_{|\\mathcal{C}_{1}|}\\)) for\\(i\\gets 0:n_{q}\\)do\\(\\triangleright\\) batch quantization of Section 5.1\\(L_{\\text{UF}}^{i}\\leftarrow\\tau\\text{-}\\text{argmin}_{c\\in\\mathcal{C}_{1}}\\|x-c \\|_{2}\\) endfor for\\(i\\gets 0:n_{q}\\)do\\(L\\leftarrow[]\\)\\(\\triangleright\\) distance table  Compute term 3 (see Section 5.2) for\\(L\\) in \\(L_{\\text{UF}}^{L}\\)do\\(\\triangleright\\)\\(\\tau\\) loops  Compute distance tables \\(T_{1},...,T_{b}\\) for\\(j\\) in \\(\\mathcal{I}_{L}\\)do\\(\\triangleright\\) distance estimation, Equation (10) \\(d\\leftarrow\\|x_{i}-q(y_{j})\\|_{2}^{2}\\)  Append \\((d,L,j)\\) to \\(L\\) endfor endfor\\(R_{i}\\)\\(\\leftarrow\\) k-select smallest distances \\(d\\) from \\(L\\) endfor return R endfunction\n' +
      '```\n' +
      '\n' +
      '**Algorithm 4** IVFPQ batch search routine\n' +
      '\n' +
      '### Multi-GPU parallelism\n' +
      '\n' +
      'Modern servers can support several GPUs. We employ this capability for both compute power and memory.\n' +
      '\n' +
      '**Replication.** If an index instance fits in the memory of a single GPU, it can be replicated across \\(\\mathcal{R}\\) different GPUs. To query \\(n_{\\text{q}}\\) vectors, each replica handles a fraction \\(n_{\\text{q}}/\\mathcal{R}\\) of the queries, joining the results back together on a single GPU or in CPU memory. Replication has near linear speedup, except for a potential loss in efficiency for small \\(n_{\\text{q}}\\).\n' +
      '\n' +
      '**Sharding.** If an index instance does not fit in the memory of a single GPU, an index can be sharded across \\(\\mathcal{S}\\) different GPUs. For adding \\(\\ell\\) vectors, each shard receives \\(\\ell/\\mathcal{S}\\) of the vectors, and for query, each shard handles the full query set \\(n_{\\text{q}}\\), joining the partial results (an additional round of \\(k\\)-selection is still required) on a single GPU or in CPU memory. For a given index size \\(\\ell\\), sharding will yield a speedup (sharding has a query of \\(n_{\\text{q}}\\) against \\(\\ell/\\mathcal{S}\\) versus replication with a query of \\(n_{\\text{q}}/\\mathcal{R}\\) against \\(\\ell\\)), but is usually less than pure replication due to fixed overhead and cost of subsequent \\(k\\)-selection.\n' +
      '\n' +
      'Replication and sharding can be used together (\\(\\mathcal{S}\\) shards, each with \\(\\mathcal{R}\\) replicas for \\(\\mathcal{S}\\times\\mathcal{R}\\) GPUs in total). Sharding or replication are both fairly trivial, and the same principle can be used to distribute an index across multiple machines.\n' +
      '\n' +
      '## 6 Experiments & Applications\n' +
      '\n' +
      'This section compares our GPU \\(k\\)-selection and nearest-neighbor approach to existing libraries. Unless stated otherwise, experiments are carried out on a 2\\(\\times\\)2.8GHz Intel Xeon E5-2680v2 with 4 Maxwell Titan X GPUs on CUDA 8.0.\n' +
      '\n' +
      '### k-selection performance\n' +
      '\n' +
      'We compare against two other GPU small \\(k\\)-selection implementations: the row-based Merge Queue with Buffered Search and Hierarchical Partition extracted from the _fgbnn_ library of Tang et al. [41] and Truncated Bitonic Sort (_TBiS_) from Sismanis et al. [40]. Both were extracted from their respective exact search libraries.\n' +
      '\n' +
      'We evaluate \\(k\\)-selection for \\(k=100\\) and \\(1000\\) of each row from a row-major matrix \\(n_{q}\\times\\ell\\) of random 32-bit floating point values on a single Titan X. The batch size \\(n_{q}\\) is fixed at \\(10000\\), and the array lengths \\(\\ell\\) vary from \\(1000\\) to \\(128000\\). Inputs and outputs to the problem remain resident in GPU memory, with the output being of size \\(n_{q}\\times k\\), with corresponding indices. Thus, the input problem sizes range from \\(40\\,\\text{MB}\\) (\\(\\ell\\!=\\!1000\\)) to \\(5.12\\,\\text{GB}\\) (\\(\\ell\\!=\\!128\\)k). TBiS requires large auxiliary storage, and is limited to \\(\\ell\\leq 48000\\) in our tests.\n' +
      '\n' +
      'Figure 3 shows our relative performance against TBiS and fignn. It also includes the peak possible performance given by the memory bandwidth limit of the Titan X. The relative performance of WarpSelect over figkn increases for larger \\(k\\); even TBiS starts to outperform figknn for larger \\(\\ell\\) at \\(k=1000\\). We look especially at the largest \\(\\ell=128000\\). WarpSelect is \\(1.62\\times\\) faster at \\(k=100\\), \\(2.01\\times\\) at \\(k=1000\\). Performance against peak possible drops off for all implementations at larger \\(k\\). WarpSelect operates at \\(55\\%\\) of peak at \\(k=100\\) but only \\(16\\%\\) of peak at \\(k=1000\\). This is due to additional overhead associated with bigger thread queues and merge/sort networks for large \\(k\\).\n' +
      '\n' +
      '**Differences from figknn.** WarpSelect is influenced by figknn, but has several improvements: all state is maintained in registers (no shared memory), no inter-warp synchronization or buffering is used, no "hierarchical partition", the \\(k\\)-selection can be fused into other kernels, and it uses odd-size networks for efficient merging and sorting.\n' +
      '\n' +
      '### k-means clustering\n' +
      '\n' +
      'The exact search method with \\(k=1\\) can be used by a \\(k\\)-means clustering method in the assignment stage, to assign \\(n_{\\text{q}}\\) training vectors to \\(|\\mathcal{C}_{1}|\\) centroids. Despite the fact that it does not use the IVFADC and \\(k=1\\) selection is trivial (a parallel reduction is used for the \\(k=1\\) case, not WarpSelect), \\(k\\)-means is a good benchmark for the clustering used to train the quantizer \\(q_{1}\\).\n' +
      '\n' +
      'We apply the algorithm on MNIST8m images. The 8.1M images are grayleveled digits in 28x28 pixels, linearized to vectors of 784-d. We compare this \\(k\\)-means implementation to the GPU \\(k\\)-means of BIDMach [11], which was shown to be more efficient than several distributed \\(k\\)-means implementations that require dozens of machines3. Both algorithms were run for 20 iterations. Table 1 shows that our implementation is more than \\(\\mathbf{2}\\times\\)**faster**, although both are built upon cuBLAS. Our implementation receives some benefit from the \\(k\\)-selection fusion into L2 distance computation. For multi-GPU execution via replicas, the speedup is close to linear for large enough problems (\\(3.16\\times\\) for 4 GPUs with 4096 centroids). Note that this benchmark is somewhat unrealistic, as one would typically sub-sample the dataset randomly when so few centroids are requested.\n' +
      '\n' +
      'Footnote 3: BIDMach numbers from [https://github.com/BIDData/BIDMach/wiki/Benchmarks#KMeans](https://github.com/BIDData/BIDMach/wiki/Benchmarks#KMeans)\n' +
      '\n' +
      '**Large scale.** We can also compare to [3], an approximate CPU method that clusters \\(10^{8}\\) 128-d vectors to 85k centroids. Their clustering method runs in 46 minutes, but requires 56 minutes (at least) of pre-processing to encode the vectors. Our method performs _exact_ k-means on 4 GPUs in 52 minutes without any pre-processing.\n' +
      '\n' +
      '### Exact nearest neighbor search\n' +
      '\n' +
      'We consider a classical dataset used to evaluate nearest neighbor search: Sift1M [25]. Its characteristic sizes are \\(\\ell=10^{6}\\), \\(d=128\\), \\(n_{\\text{q}}=10^{4}\\). Computing the partial distance matrix \\(D^{\\prime}\\) costs \\(n_{\\text{q}}\\times\\ell\\times d=1.28\\) Tflop, which runs in less than one second on current GPUs. Figure 4 shows the cost of the distance computations against the cost of our tiling of the GEMM for the \\(-2\\left\\langle x_{j},y_{\\text{t}}\\right\\rangle\\) term of Equation 2 and the peak possible \\(k\\)-selection performance on the distance matrix of size \\(n_{\\text{q}}\\times\\ell\\), which additionally accounts for reading the tiled result matrix \\(D^{\\prime}\\) at peak memory bandwidth.\n' +
      '\n' +
      'In addition to our method from Section 5, we include times from the two GPU libraries evaluated for \\(k\\)-selection performance in Section 6.1. We make several observations:\n' +
      '\n' +
      '* for \\(k\\)-selection, the naive algorithm that sorts the full result array for each query using thrust::sort_by_key is more than \\(10\\times\\) slower than the comparison methods;\n' +
      '* L2 distance and \\(k\\)-selection cost is dominant for all but our method, which has **85 % of the peak** possible performance, assuming GEMM usage and our tiling\n' +
      '\n' +
      '\\begin{table}\n' +
      '\\begin{tabular}{l c c c} \\hline \\hline  & & \\multicolumn{2}{c}{\\# centroids} \\\\ method & \\# GPUs & 256 & 4096 \\\\ \\hline BIDMach [11] & 1 & 320 s & 735 s \\\\ Ours & 1 & 140 s & 316 s \\\\ Ours & 4 & 84 s & 100 s \\\\ \\hline \\hline \\end{tabular}\n' +
      '\\end{table}\n' +
      'Table 1: MNIST8m \\(k\\)-means performance\n' +
      '\n' +
      'Figure 3: Runtimes for different \\(k\\)-selection methods, as a function of array length \\(\\ell\\). Simultaneous arrays processed are \\(n_{q}=10000\\). \\(k=100\\) for full lines, \\(k=1000\\) for dashed lines.\n' +
      '\n' +
      'of the partial distance matrix \\(D^{\\prime}\\) on top of GEMM is close to optimal. The cuBLAS GEMM itself has low efficiency for small reduction sizes (\\(d=128\\));\n' +
      '* Our fused L2/\\(k\\)-selection kernel is important. Our same exact algorithm without fusion (requiring an additional pass through \\(D^{\\prime}\\)) is at least 25% slower.\n' +
      '\n' +
      'Efficient \\(k\\)-selection is even more important in situations where approximate methods are used to compute distances, because the relative cost of \\(k\\)-selection with respect to distance computation increases.\n' +
      '\n' +
      '### Billion-scale approximate search\n' +
      '\n' +
      'There are few studies on GPU-based approximate nearest-neighbor search on large datasets (\\(\\ell\\gg 10^{6}\\)). We report a few comparison points here on index search, using standard datasets and evaluation protocol in this field.\n' +
      '\n' +
      '**SIFT1M.** For the sake of completeness, we first compare our GPU search speed on Sift1M with the implementation of Wieschollek et al. [47]. They obtain a nearest neighbor recall at 1 (fraction of queries where the true nearest neighbor is in the top 1 result) of R@1 = 0.51, and R@100 = 0.86 in 0.02 ms per query on a Titan X. For the same time budget, our implementation obtains R@1 = 0.80 and R@100 = 0.95.\n' +
      '\n' +
      '**SIFT1B.** We compare again with Wieschollek et al., on the Sift1B dataset [26] of 1 billion SIFT image features at \\(n_{\\mathrm{q}}=10^{4}\\). We compare the search performance in terms of same memory usage for similar accuracy (more accurate methods may involve greater search time or memory usage). On a single GPU, with \\(m=8\\) bytes per vector, R@10 = 0.376 in 17.7 \\(\\mu\\)s per query vector, versus their reported R@10 = 0.35 in 150 \\(\\mu\\)s per query vector. Thus, our implementation is more accurate at a speed **8.5\\(\\times\\) faster**.\n' +
      '\n' +
      '**DEEP1B.** We also experimented on the Deep1B dataset [6] of \\(\\ell\\)=1 billion CNN representations for images at \\(n_{\\mathrm{q}}=10^{4}\\). The paper that introduces the dataset reports CPU results (1 thread): R@1 = 0.45 in 20 ms search time per vector. We use a PQ encoding of \\(m=20\\), with \\(d=80\\) via OPQ [17], and \\(|\\mathcal{C}_{1}|=2^{18}\\), which uses a comparable dataset storage as the original paper (20 GB). This requires multiple GPUs as it is too large for a single GPU\'s global memory, so we consider 4 GPUs with \\(\\mathcal{S}=2\\), \\(\\mathcal{R}=2\\). We obtain a R@1 = 0.4517 in 0.0133 ms per vector. While the hardware platforms are different, it shows that making searches on GPUs is a game-changer in terms of speed achievable on a single machine.\n' +
      '\n' +
      '### The k-NN graph\n' +
      '\n' +
      'An example usage of our similarity search method is to construct a \\(k\\)_-nearest neighbor graph_ of a dataset via brute force (all vectors queried against the entire index).\n' +
      '\n' +
      '**Experimental setup.** We evaluate the trade-off between speed, precision and memory on two datasets: 95 million images from the Yfcc100M dataset [42] and Deep1B. For Yfcc100M, we compute CNN descriptors as the one-before-last layer of a ResNet [23], reduced to \\(d\\) = 128 with PCA.\n' +
      '\n' +
      'The evaluation measures the trade-off between:\n' +
      '\n' +
      '* Speed: How much time it takes to build the IVFADC index from scratch and construct the whole \\(k\\)-NN graph (\\(k=10\\)) by searching nearest neighbors for all vectors in the dataset. Thus, this is an end-to-end test that includes indexing as well as search time;\n' +
      '* Quality: We sample 10,000 images for which we compute the exact nearest neighbors. Our accuracy measure is the fraction of 10 found nearest neighbors that are within the ground-truth 10 nearest neighbors.\n' +
      '\n' +
      'For Yfcc100M, we use a coarse quantizer (\\(2^{16}\\) centroids), and consider \\(m=16\\), 32 and 64 byte PQ encodings for each vector. For Deep1B, we pre-process the vectors to \\(d=120\\) via OPQ, use \\(|\\mathcal{C}_{1}|=2^{18}\\) and consider \\(m=20\\), 40. For a given encoding, we vary \\(\\tau\\) from 1 to 256, to obtain trade-offs between efficiency and quality, as seen in Figure 5.\n' +
      '\n' +
      'Figure 4: Exact search \\(k\\)-NN time for the SIFT1M dataset with varying \\(k\\) on 1 Titan X GPU.\n' +
      '\n' +
      'Figure 5: Speed/accuracy trade-off of brute-force 10-NN graph construction for the YFCC100M and DEEP1B datasets.\n' +
      '\n' +
      '**Discussion.** For Yfcc100M we used \\(\\mathcal{S}=1\\), \\(\\mathcal{R}=4\\). An accuracy of more than 0.8 is obtained in 35 minutes. For Deep1B, a lower-quality graph can be built in 6 hours, with higher quality in about half a day. We also experimented with more GPUs by doubling the replica set, using 8 Maxwell M40s (the M40 is roughly equivalent in performance to the Titan X). Performance is improved sub-linearly (\\(\\sim 1.6\\times\\) for \\(m=20\\), \\(\\sim 1.7\\times\\) for \\(m=40\\)).\n' +
      '\n' +
      'For comparison, the largest \\(k\\)-NN graph construction we are aware of used a dataset comprising 36.5 million 384-d vectors, which took a cluster of 128 CPU servers 108.7 hours of compute [45], using NN-Descent [15]. Note that NN-Descent could also build or refine the \\(k\\)-NN graph for the datasets we consider, but it has a large memory overhead over the graph storage, which is already 80 GB for Deep1B. Moreover it requires random access across all vectors (384 GB for Deep1B).\n' +
      '\n' +
      'The largest GPU \\(k\\)-NN graph construction we found is a brute-force construction using exact search with GEMM, of a dataset of 20 million 15,000-d vectors, which took a cluster of 32 Tesla C2050 GPUs 10 days [14]. Assuming computation scales with GEMM cost for the distance matrix, this approach for Deep1B would take an impractical 200 days of computation time on their cluster.\n' +
      '\n' +
      '### Using the k-NN graph\n' +
      '\n' +
      'When a \\(k\\)-NN graph has been constructed for an image dataset, we can find paths in the graph between any two images, provided there is a single connected component (this is the case). For example, we can search the shortest path between two images of flowers, by propagating neighbors from a starting image to a destination image. Denoting by \\(S\\) and \\(D\\) the source and destination images, and \\(d_{ij}\\) the distance between nodes, we search the path \\(P=\\{p_{1},...,p_{n}\\}\\) with \\(p_{1}=S\\) and \\(p_{n}=D\\) such that\n' +
      '\n' +
      '\\[\\min_{P}\\,\\max_{i=1..n}\\,d_{p_{i}p_{i+1}}, \\tag{12}\\]\n' +
      '\n' +
      '_i.e._, we want to favor smooth transitions. An example result is shown in Figure 6 from Yfcc100M4. It was obtained after 20 seconds of propagation in a \\(k\\)-NN graph with \\(k=15\\) neighbors. Since there are many flower images in the dataset, the transitions are smooth.\n' +
      '\n' +
      'Footnote 4: The mapping from vectors to images is not available for Deep1B\n' +
      '\n' +
      '## 7 Conclusion\n' +
      '\n' +
      'The arithmetic throughput and memory bandwidth of GPUs are well into the teraflops and hundreds of gigabytes per second. However, implementing algorithms that approach these performance levels is complex and counter-intuitive. In this paper, we presented the algorithmic structure of similarity search methods that achieves near-optimal performance on GPUs.\n' +
      '\n' +
      'This work enables applications that needed complex approximate algorithms before. For example, the approaches presented here make it possible to do exact \\(k\\)-means clustering or to compute the \\(k\\)-NN graph with simple brute-force approaches in less time than a CPU (or a cluster of them) would take to do this approximately.\n' +
      '\n' +
      'GPU hardware is now very common on scientific workstations, due to their popularity for machine learning algorithms. We believe that our work further demonstrates their interest for database applications. Along with this work, we are publishing a carefully engineered implementation of this paper\'s algorithms, so that these GPUs can now also be used for efficient similarity search.\n' +
      '\n' +
      '## References\n' +
      '\n' +
      '* [1] T. Alabi, J. D. Blanchard, B. Gordon, and R. Steinbach. Fast k-selection algorithms for graphics processing units. _ACM Journal of Experimental Algorithmics_, 17:4.2:4.1-4.2:4.29, October 2012.\n' +
      '* [2] F. Andre, A.-M. Kermarrec, and N. L. Scouarnec. Cache locality is not enough: High-performance nearest neighbor search with product quantization fast scan. In _Proc. International Conference on Very Large DataBases_, pages 288-299, 2015.\n' +
      '* [3] Y. Avrithis, Y. Kalantidis, E. Anagnostopoulos, and I. Z. Emiris. Web-scale image clustering revisited. In _Proc. International Conference on Computer Vision_, pages 1502-1510, 2015.\n' +
      '* [4] A. Babenko and V. Lempitsky. The inverted multi-index. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 3069-3076, June 2012.\n' +
      '* [5] A. Babenko and V. Lempitsky. Improving bilayer product quantization for billion-scale approximate nearest neighbors in high dimensions. _arXiv preprint arXiv:1404.1831_, 2014.\n' +
      '* [6] A. Babenko and V. Lempitsky. Efficient indexing of billion-scale datasets of deep descriptors. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 2055-2063, June 2016.\n' +
      '* [7] R. Barrientos, J. Gomez, C. Tenllado, M. Prieto, and M. Marin. knn query processing in metric spaces using GPUs. In _International European Conference on Parallel and Distributed Computing_, volume 6852 of _Lecture Notes\n' +
      '\n' +
      'Figure 6: Path in the \\(k\\)-NN graph of 95 million images from YFCC100M. The first and the last image are given; the algorithm computes the smoothest path between them.\n' +
      '\n' +
      'in Computer Science_, pages 380-392, Bordeaux, France, September 2011. Springer.\n' +
      '* [18] K. E. Batcher. Sorting networks and their applications. In _Proc. Spring Joint Computer Conference_, AFIPS \'68 (Spring), pages 307-314, New York, NY, USA, 1968. ACM.\n' +
      '* [19] P. Boncz, W. Lehner, and T. Neumann. Special issue: Modern hardware. _The VLDB Journal_, 25(5):623-624, 2016.\n' +
      '* [20] J. Canny, D. L. W. Hall, and D. Klein. A multi-teraflop constituency parser using GPUs. In _Proc. Empirical Methods on Natural Language Processing_, pages 1898-1907. ACL, 2013.\n' +
      '* [21] J. Canny and H. Zhao. Bidmach: Large-scale learning with zero memory allocation. In _BigLearn workshop, NIPS_, 2013.\n' +
      '* [22] B. Catanzaro, A. Keller, and M. Garland. A decomposition for in-place matrix transposition. In _Proc. ACM Symposium on Principles and Practice of Parallel Programming_, PpPP \'14, pages 193-206, 2014.\n' +
      '* [23] J. Chhugani, A. D. Nguyen, V. W. Lee, W. Macy, M. Hagog, Y.-K. Chen, A. Baransi, S. Kumar, and P. Dubey. Efficient implementation of sorting on multi-core simd cpu architecture. _Proc. VLDB Endow._, 1(2):1313-1324, August 2008.\n' +
      '* [24] A. Dashti. Efficient computation of k-nearest neighbor graphs for large high-dimensional data sets on gpu clusters. Master\'s thesis, University of Wisconsin Milwaukee, August 2013.\n' +
      '* [25] W. Dong, M. Charikar, and K. Li. Efficient k-nearest neighbor graph construction for generic similarity measures. In _WWW: Proceeding of the International Conference on World Wide Web_, pages 577-586, March 2011.\n' +
      '* [26] M. Douze, H. Jegou, and F. Perronnin. Polysemous codes. In _Proc. European Conference on Computer Vision_, pages 785-801. Springer, October 2016.\n' +
      '* [27] T. Ge, K. He, Q. Ke, and J. Sun. Optimized product quantization. _IEEE Trans. PAMI_, 36(4):744-755, 2014.\n' +
      '* [28] Y. Gong and S. Lazebnik. Iterative quantization: A procrustean approach to learning binary codes. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 817-824, June 2011.\n' +
      '* [29] Y. Gong, L. Wang, R. Guo, and S. Lazebnik. Multi-scale orderless pooling of deep convolutional activation features. In _Proc. European Conference on Computer Vision_, pages 392-407, 2014.\n' +
      '* [30] A. Gordo, J. Almazan, J. Revaud, and D. Larlus. Deep image retrieval: Learning global representations for image search. In _Proc. European Conference on Computer Vision_, pages 241-257, 2016.\n' +
      '* [31] S. Han, H. Mao, and W. J. Dally. Deep compression: Compressing deep neural networks with pruning, trained quantization and huffman coding. _arXiv preprint arXiv:1510.00149_, 2015.\n' +
      '* [32] K. He, F. Wen, and J. Sun. K-means hashing: An affinity-preserving quantization method for learning binary compact codes. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 2938-2945, June 2013.\n' +
      '* [33] K. He, X. Zhang, S. Ren, and J. Sun. Deep residual learning for image recognition. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 770-778, June 2016.\n' +
      '* [34] X. He, D. Agarwal, and S. K. Prasad. Design and implementation of a parallel priority queue on many-core architectures. _IEEE International Conference on High Performance Computing_, pages 1-10, 2012.\n' +
      '* [35] H. Jegou, M. Douze, and C. Schmid. Product quantization for nearest neighbor search. _IEEE Trans. PAMI_, 33(1):117-128, January 2011.\n' +
      '* [36] H. Jegou, R. Tavenard, M. Douze, and L. Amsaleg. Searching in one billion vectors: re-rank with source coding. In _International Conference on Acoustics, Speech, and Signal Processing_, pages 861-864, May 2011.\n' +
      '* [37] Y. Kalantidis and Y. Avrithis. Locally optimized product quantization for approximate nearest neighbor search. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 2329-2336, June 2014.\n' +
      '* [38] A. Krizhevsky, I. Sutskever, and G. E. Hinton. Imagenet classification with deep convolutional neural networks. In _Advances in Neural Information Processing Systems_, pages 1097-1105, 2012.\n' +
      '* [39] F. T. Leighton. _Introduction to Parallel Algorithms and Architectures: Array, Trees, Hypercubes_. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 1992.\n' +
      '* [40] E. Lindholm, J. Nickolls, S. Oberman, and J. Montrym. NVIDIA Tesla: a unified graphics and computing architecture. _IEEE Micro_, 28(2):39-55, March 2008.\n' +
      '* [41] W. Liu and B. Vinter. Ad-heap: An efficient heap data structure for asymmetric multicore processors. In _Proc. of Workshop on General Purpose Processing Using GPUs_, pages 54:54-54:63. ACM, 2014.\n' +
      '* [42] T. Mikolov, I. Sutskever, K. Chen, G. S. Corrado, and J. Dean. Distributed representations of words and phrases and their compositionality. In _Advances in Neural Information Processing Systems_, pages 3111-3119, 2013.\n' +
      '* [43] L. Monroe, J. Wendelberger, and S. Michalak. Randomized selection on the GPU. In _Proc. ACM Symposium on High Performance Graphics_, pages 89-98, 2011.\n' +
      '* [44] M. Norouzi and D. Fleet. Cartesian k-means. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 3017-3024, June 2013.\n' +
      '* [45] M. Norouzi, A. Punjani, and D. J. Fleet. Fast search in Hamming space with multi-index hashing. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 3108-3115, 2012.\n' +
      '* [46] J. Pan and D. Manocha. Fast GPU-based locality sensitive hashing for k-nearest neighbor computation. In _Proc. ACM International Conference on Advances in Geographic Information Systems_, pages 211-220, 2011.\n' +
      '* [47] L. Pauleve, H. Jegou, and L. Amsaleg. Locality sensitive hashing: a comparison of hash function types and querying mechanisms. _Pattern recognition letters_, 31(11):1348-1358, August 2010.\n' +
      '* [48] O. Shamir. Fundamental limits of online and distributed algorithms for statistical learning and estimation. In _Advances in Neural Information Processing Systems_, pages 163-171, 2014.\n' +
      '* [49] A. Sharif Razavian, H. Azizpour, J. Sullivan, and S. Carlsson. CNN features off-the-shelf: an astounding baseline for recognition. In _CVPR workshops_, pages 512-519, 2014.\n' +
      '* [50] N. Sismanis, N. Pitsianis, and X. Sun. Parallel search of k-nearest neighbors with synchronous operations. In _IEEE High Performance Extreme Computing Conference_, pages 1-6, 2012.\n' +
      '* [51] X. Tang, Z. Huang, D. M. Evers, S. Mills, and M. Guo. Efficient selection algorithm for fast k-nn search on GPUs. In _IEEE International Parallel & Distributed Processing Symposium_, pages 397-406, 2015.\n' +
      '* [52] B. Thomee, D. A. Shamma, G. Friedland, B. Elizalde, K. Ni, D. Poland, D. Borth, and L.-J. Li. YFCC100M: The new data in multimedia research. _Communications of the ACM_, 59(2):64-73, January 2016.\n' +
      '* [53] V. Volkov and J. W. Demmel. Benchmarking GPUs to tune dense linear algebra. In _Proc. ACM/IEEE Conference on Supercomputing_, pages 31:1-31:11, 2008.\n' +
      '* [54] A. Wakatani and A. Murakami. GPGPU implementation of nearest neighbor search with product quantization. In _IEEE International Symposium on Parallel and Distributed Processing with Applications_, pages 248-253, 2014.\n' +
      '* [55] T. Warashina, K. Aoyama, H. Sawada, and T. Hattori. Efficient k-nearest neighbor graph construction using mapreduce for large-scale data sets. _IEICE Transactions_,97-D(12):3142-3154, 2014.\n' +
      '* [46] R. Weber, H.-J. Schek, and S. Blott. A quantitative analysis and performance study for similarity-search methods in high-dimensional spaces. In _Proc. International Conference on Very Large DataBases_, pages 194-205, 1998.\n' +
      '* [47] P. Wieschollek, O. Wang, A. Sorkine-Horunung, and H. P. A. Lensch. Efficient large-scale approximate nearest neighbor search on the GPU. In _Proc. IEEE Conference on Computer Vision and Pattern Recognition_, pages 2027-2035, June 2016.\n' +
      '* [48] S. Williams, A. Waterman, and D. Patterson. Roofline: An insightful visual performance model for multicore architectures. _Communications of the ACM_, 52(4):65-76, April 2009.\n' +
      '\n' +
      '## Appendix: Complexity analysis of WarpSelect\n' +
      '\n' +
      'We derive the average number of times updates are triggered in WarpSelect, for use in Section 4.3.\n' +
      '\n' +
      'Let the input to \\(k\\)-selection be a sequence \\(\\{a_{1},a_{2},...,a_{\\ell}\\}\\) (1-based indexing), a randomly chosen permutation of a set of distinct elements. Elements are read sequentially in \\(c\\) groups of size \\(w\\) (the warp; in our case, \\(w=32\\)); assume \\(\\ell\\) is a multiple of \\(w\\), so \\(c=\\ell/w\\). Recall that \\(t\\) is the thread queue length. We call elements prior to or at position \\(n\\) in the min-\\(k\\) seen so far the _successive min-\\(k\\) (at \\(n\\))_. The likelihood that \\(a_{n}\\) is in the successive min-\\(k\\) at \\(n\\) is:\n' +
      '\n' +
      '\\[\\alpha(n,k):=\\begin{cases}1&\\text{if }n\\leq k\\\\ k/n&\\text{if }n>k\\end{cases} \\tag{13}\\]\n' +
      '\n' +
      'as each \\(a_{n}\\), \\(n>k\\) has a \\(k/n\\) chance as all permutations are equally likely, and all elements in the first \\(k\\) qualify.\n' +
      '\n' +
      '**Counting the insertion sorts.** In a given lane, an insertion sort is triggered if the incoming value is in the successive min-\\(k+t\\) values, but the lane has "seen" only \\(wc_{0}+(c-c_{0})\\) values, where \\(c_{0}\\) is the previous won warp ballot. The probability of this happening is:\n' +
      '\n' +
      '\\[\\alpha(wc_{0}+(c-c_{0}),k+t)\\approx\\frac{k+t}{wc}\\text{ for }c>k. \\tag{14}\\]\n' +
      '\n' +
      'The approximation considers that the thread queue has seen _all_ the \\(wc\\) values, not just those assigned to its lane. The probability of _any_ lane triggering an insertion sort is then:\n' +
      '\n' +
      '\\[1-\\left(1-\\frac{k+t}{wc}\\right)^{w}\\approx\\frac{k+t}{c}. \\tag{15}\\]\n' +
      '\n' +
      'Here the approximation is a first-order Taylor expansion. Summing up the probabilities over \\(c\\) gives an expected number of insertions of \\(N_{2}\\approx(k+t)\\log(c)=\\mathcal{O}(k\\log(\\ell/w))\\).\n' +
      '\n' +
      '**Counting full sorts.** We seek \\(N_{3}=\\pi(\\ell,k,t,w)\\), the expected number of full sorts required for WarpSelect.\n' +
      '\n' +
      '**Single lane.** For now, we assume \\(w=1\\), so \\(c=\\ell\\). Let \\(\\gamma(\\ell,m,k)\\) be the probability that in an sequence \\(\\{a_{1},...,a_{\\ell}\\}\\), exactly \\(m\\) of the elements as encountered by a sequential scanner (\\(w=1\\)) are in the successive min-\\(k\\). Given \\(m\\), there are \\(\\binom{\\ell}{m}\\) places where these successive min-\\(k\\) elements can occur. It is given by a recurrence relation:\n' +
      '\n' +
      '\\[\\gamma(\\ell,m,k):=\\begin{cases}1&\\ell=0\\text{ and }m=0\\\\ 0&\\ell=0\\text{ and }m>0\\\\ 0&\\ell>0\\text{ and }m=0\\\\ (\\gamma(\\ell-1,m-1,k)\\cdot\\alpha(\\ell,k)+\\\\ \\gamma(\\ell-1,m,k)\\cdot(1-\\alpha(\\ell,k)))&\\text{otherwise.}\\end{cases} \\tag{16}\\]\n' +
      '\n' +
      'The last case is the probability of: there is a \\(\\ell-1\\) sequence with \\(m-1\\) successive min-\\(k\\) elements preceding us, and the current element is in the successive min-\\(k\\), or the current element is not in the successive min-\\(k\\), \\(m\\) ones are before us. We can then develop a recurrence relationship for \\(\\pi(\\ell,k,t,1)\\). Note that\n' +
      '\n' +
      '\\[\\delta(\\ell,b,k,t):=\\sum_{m=bt}^{\\min((bt+\\max(0,t-1)),\\ell)}\\gamma(\\ell,m,k) \\tag{17}\\]\n' +
      '\n' +
      'for \\(b\\) where \\(0\\leq bt\\leq\\ell\\) is the fraction of all sequences of length \\(\\ell\\) that will force \\(b\\) sorts of data by winning the thread queue ballot, as there have to be \\(bt\\) to \\((bt+\\max(0,t-1))\\) elements in the successive min-\\(k\\) for these sorts to happen (as the min-\\(k\\) elements will overflow the thread queues). There are at most \\(\\lfloor\\ell/t\\rfloor\\) won ballots that can occur, as it takes \\(t\\) separate sequential current min-\\(k\\) seen elements to win the ballot. \\(\\pi(\\ell,k,t,1)\\) is thus the expectation of this over all possible \\(b\\):\n' +
      '\n' +
      '\\[\\pi(\\ell,k,t,1)=\\sum_{b=1}^{\\lfloor\\ell/t\\rfloor}b\\cdot\\delta(\\ell,b,k,t). \\tag{18}\\]\n' +
      '\n' +
      'This can be computed by dynamic programming. Analytically, note that for \\(t=1\\), \\(k=1\\), \\(\\pi(\\ell,1,1,1)\\) is the harmonic number \\(H_{\\ell}=1+\\frac{1}{2}+\\frac{1}{3}+...+\\frac{1}{2}\\), which converges to \\(\\ln(\\ell)+\\gamma\\) (the Euler-Mascheroni constant \\(\\gamma\\)) as \\(\\ell\\to\\infty\\).\n' +
      '\n' +
      'For \\(t=1,k>1,\\ell>k\\), \\(\\pi(\\ell,k,1,1)=k+k(H_{\\ell}-H_{k})\\) or \\(\\mathcal{O}(k\\log(\\ell))\\), as the first \\(k\\) elements are in the successive min-\\(k\\), and the expectation for the rest is \\(\\frac{k}{k+1}+\\frac{k}{k+2}+...+\\frac{k}{\\ell}\\).\n' +
      '\n' +
      'For \\(t>1,k>1,\\ell>k\\), note that there are some number \\(D\\), \\(k\\leq D\\leq\\ell\\) of successive min-\\(k\\) determinations \\(D\\) made for each possible \\(\\{a_{1},...,a_{\\ell}\\}\\). The number of won ballots for each case is by definition \\(\\lfloor D/t\\rfloor\\), as the thread queue must fill up \\(t\\) times. Thus, \\(\\pi(\\ell,k,t,1)=\\mathcal{O}(k\\log(\\ell)/t)\\).\n' +
      '\n' +
      '**Multiple lanes.** The \\(w>1\\) case is complicated by the fact that there are joint probabilities to consider (if more than one of the \\(w\\) workers triggers a sort for a given group, only one sort takes place). However, the likelihood can be bounded. Let \\(\\pi^{\\prime}(\\ell,k,t,w)\\) be the expected won ballots assuming no mutual interference between the \\(w\\) workers for winning ballots (i.e., we win \\(b\\) ballots if there are \\(b\\leq w\\) workers that independently win a ballot at a single step), but with the shared min-\\(k\\) set after each sort from the joint sequence. Assume that \\(k\\geq w\\). Then:\n' +
      '\n' +
      '\\[\\pi^{\\prime}(\\ell,k,1,w) \\leq w\\Bigg{(}\\left\\lceil\\frac{k}{w}\\right\\rceil+\\sum_{i=1}^{\\lceil \\ell/w\\rceil-\\lceil k/w\\rceil}\\frac{k}{w(\\lceil k/w\\rceil+i)}\\Bigg{)} \\tag{19}\\] \\[\\leq w\\pi(\\lceil\\ell/w\\rceil,k,1,1)=\\mathcal{O}(wk\\log(\\ell/w))\\]\n' +
      '\n' +
      'where the likelihood of the \\(w\\) workers seeing a successive min-\\(k\\) element has an upper bound of that of the first worker at each step. As before, the number of won ballots is scaled by \\(t\\), so \\(\\pi^{\\prime}(\\ell,k,t,w)=\\mathcal{O}(wk\\log(\\ell/w)/t)\\). Mutual interference can only reduce the number of ballots, so we obtain the same upper bound for \\(\\pi(\\ell,k,t,w)\\).\n' +
      '\n';
  </script>
  <style>
    #content {
      max-width: 800px;
      margin: auto;
    }
  </style>
  <script>
    let script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/mathpix-markdown-it@1.0.40/es5/bundle.js";
    document.head.append(script);

    script.onload = function() {
      const isLoaded = window.loadMathJax();
      if (isLoaded) {
        console.log('Styles loaded!')
      }

      const el = window.document.getElementById('content-text');
      if (el) {
        const options = {
          htmlTags: true
        };
        const html = window.render(text, options);
        el.outerHTML = html;
      }
    };
  </script>
</head>
<body>
  <div id="content"><div id="content-text"></div></div>
</body>
</html>