[MISSING_PAGE_FAIL:1]

enhancements need to provide both broad and deep exploration of the state-space, thus resulting in high source code coverage of the network protocol implementations. Our preliminary study provides a detailed survey and taxonomy on fuzzing and symbolic execution for verifying network protocol implementations. Thus, we make two significant contributions. First, we describe a novel verification technique that uses symbolic execution combined with fuzzing to generate automatically high-coverage test packets from the network protocol implementations. We detect various generic implementation errors, e.g., invalid memory access or division-by-zero, which can cause the implementation of the network protocol to crash. We use fuzzing for an initial exploration of the network protocol and then apply symbolic execution to generate high-coverage test packets for network protocol implementations automatically. Second, our experimental results show that ESBMC (Fuzzing et al., 2019) can be further developed to detect security vulnerabilities in network protocols. In particular, ESBMC was able to detect a security vulnerability targeted at the FTP implementation faster than other existing tools such as Mapzcheck (Marcus et al., 2019), KLEE (Kaley et al., 2019), and SPIKE (Barcus et al., 2019).

## 2. Preliminaries

### Network Protocol

A network can be defined as a group of entities that are interconnected with communication technologies and allow the exchange of information (Bradbury et al., 2017). The communicating entities require an agreement for exchanging information, and these agreements are known as _network protocols_. The messages exchanged by these entities are referred to as _packets_. A sequence of packets is called a _packet stream_. Information related to methods, behavior, and packet formats are described in documents when designing a network protocol (Marcus et al., 2019); these documents form the _protocol specification_, which is routinely referenced by developers of a protocol implementation. Implementations of network protocols are referred to as _network daemons_ in UNIX and other operating systems. When requirements of a protocol \(P\) are specified, these requirements are described in the protocol specification \(S\), and the specification is implemented in \(I\). For example, File Transfer Protocol (FTP) is a standard network protocol used for the transfer of computer files between a client and a server on a computer network (Kleiner et al., 2017); it is described in several Request For Comments (RFC) documents that form the protocol specification. Several implementations of the specification exist, such as FileZilla (Windows) and Pure-FTPd (Unix). FTP is an application-level protocol used on (TCP/IP) networks for file exchange. The FTP is implemented as follows. First, a client uses port 21 to connect to the server. The client requests are sent in ASCII using this socket. A new socket is opened on port 20 with the server when the client requests to transfer data. Client requests mostly consist of a four-letter message type followed by the actual message. The server responses are in ASCII, where the first three digits correspond to a status code followed by an optional message. We use the FTP implementation as our case study to evaluate our prototype.

### Fuzzing

Fuzzing is a software testing technique to exploit vulnerabilities in software systems (Kleiner et al., 2017). Fuzzing prepares random or semi-random inputs to the target network protocol. Critical security flaws most often occur because program inputs are not adequately checked (Fuzzing et al., 2019). Since these inputs are random, their unexpected and improper appearance in a target network protocol is highly probable. If the target network protocol does not reject these improper inputs, it will hang or crash during fuzz testing. Fuzzing is a quick and cost-effective method for locating security vulnerabilities in network protocols. Software systems that cannot endure fuzzing could potentially lead to security holes. For example, in the FTP protocol, a network analyzer such as Wireshark extracts specifications of a network protocol implementation from conversations recorded between server/client sessions. Once the network protocol specifications are extracted, the fuzzing engine is loaded with an extendable list of fuzzing functions. Initially, the fuzzing engine sets its state to the root of the protocol. It then monitors the input traffic, thereby making appropriate transitions and applying fuzzing functions.

### Symbolic Execution

Symbolic execution is widely used to find security vulnerabilities by analyzing program behavior and generating test cases (Fuzzing et al., 2019). Using symbolic input values instead of concrete input values is the primary concept of symbolic execution. This method treats the paths as symbolic constraints and solves the constraints to output a concrete input as a test case. In terms of network protocols, we extract the message formats from the protocol specification of the target network protocol implementation. Then, we use these message formats to construct a concrete packet, which is used to mark the ID field of this packet as symbolic values to form a symbolic packet. After that, we invoke the symbolic execution engine to explore possible paths of the protocol program using two approaches: path-based symbolic execution and BMC.

### Challenges in Verifying Network Protocols

There exist many challenges to verify network protocols. First, the network protocol size is large and complicated since it involves different communicating entities. Second, testing and verification is a long process in which many errors appear only after a long period of operation. Avoiding the path explosion is one of the most difficult challenges we may face when we use a symbolic execution engine. The possible number of execution paths considered is so large, which only a small part of the program state-space is explored. Lastly, if we test a protocol in a virtual environment is not the same as testing it in a real environment. Thus, detecting vulnerabilities in network protocols in the real-world is a challenge, which deserves specialized verification approaches to ensure behavior correctness.

## 3. Finding Vulnerabilities in Network Protocol Implementations

Network protocol implementations are often prone to vulnerabilities caused by the developer mistakes, which include: _buffer overflow_, which is a situation where a running program attempts to write data outside the memory buffer, which is not intended to store this data (Barcus et al., 2019); _memory leak_, which occurs when programmers create a memory in a heap and forget to delete it (Zhu et al., 2019); _denial-of-service attack_ (DoS), which is a security event that occurs when an attacker prevents legitimate users from accessing specific computer systems, devices, services, or other IT resources (Kang et al., 2017). As an example, a vulnerability in the Cisco Discovery Protocol (CDP) module of Cisco IOS XE Software Releases 16.6.1 and 16.6.2 could allow an unauthenticated, adjacent attacker to cause a memory leak, which could lead to a DoS condition (Kang et al., 2017).

### _FuSeBMC_ for detecting security vulnerabilities

After searching for tools that combine fuzzing and symbolic execution, we have found just one promising tool: Driller (Kang et al., 2017). There exist other methods that claim to combine fuzzing and symbolic execution, but we have not found any tool implementation available (Kang et al., 2017). Given the current knowledge in software verification and testing, there exists no tool that has been developed in the field of network protocols, which require dealing with packets in the network is one of the challenges that were not addressed by tools that integrate the two technologies. However, some tools that do not combine the two technologies faced some problems such as path explosion or achieved low coverage. Therefore, we propose a novel approach called _FuSeBMC_ for detecting security vulnerabilities in network protocol implementations using fuzzing and symbolic execution. The main idea is to generate a set of test input packets using fuzzing to explore the state-space initially. These test inputs will guide the symbolic execution and BMC engines to explore the parts that fuzzing could not reach. In other words, it will legalize the scanning process and avoid problems such as code explosion. Then, use symbolic execution and BMC to achieve high-code coverage and replay them against an implementation, thereby observing potential violations of rules derived from the protocol specification. We devise an exploration method that achieves broad and in-depth exploration of the state-space of a target implementation.

Our prototype is illustrated in Fig. 1. There exist five steps to verify network protocol implementation. First, the protocol specification analyzer produces the concrete packet. We use here the Wireshark (Wiershaw, 2017) to capture the packet that will be sent between the client and the FTP server. Second, our prototype employs American Fuzzy (AFL) (Zhou et al., 2017), which is a tool that uses initial test-cases and genetic mutations to generate new test cases. AFL works with the target software that accepts inputs from the standard input or a file. We fuzz the software for exploring the functions. Then, we compute the function coverage achieved by the fuzzer. Third, we mark the input packet as a symbolic packet that would result in too many paths, and most of these paths would not increase code coverage because they would refer to invalid packets, which are usually discarded by an implementation. Typically a network packet consists of multiple fields, which are part of the packet header. Most protocol implementations contain logic for handling these fields. Therefore, _FuSeBMC_ uses these fields as symbolic variables instead of entire input packets. Fourth, we use path-based symbolic execution and BMC to reach those functions that were uncovered by the fuzzer. Because of an initial exploratory phase with fuzzer, a symbolic execution engine becomes capable of excluding the functions that can be reached quickly and, hence, more time can be allocated to intricate and deep functions. Lastly, the symbolic marker converts the concrete packet to a symbolic packet by marking some bytes of the packet as symbolic values.

Our _FuSeBMC_ prototype builds on top of Map2Check (Kang et al., 2017) as a path-based symbolic execution engine combined with fuzzing and ESBMC (Kang et al., 2018) as a state-of-the-art BMC engine. Both tools explore all program paths of the network protocol software and produce a concrete packet while the memory monitor module reports and records the crashes. For example, if the user provides an instruction to mark the flags field as symbolic, our prototype replaces the concrete value of this field within the packet with symbolic values while keeping the other fields concrete. Thus, _FuSeBMC_ explores possible execution paths corresponding to the various input packets having different flags values. At the end of each execution path, it stores the concrete test packet for a given path on disk.

## 4. Experimental Evaluation

### Benchmarks and Setup

When we designed _FuSeBMC_, we defined two main criteria to hold in our prototype. First, the ability to detect bugs that can be evaluated by validating network protocol implementations against their protocol specifications. Second, the low verification time to find security vulnerabilities when compared to existing approaches. We conducted experiments on a simple File Transfer Protocol (FTP) written in the C programming language and a server (Vulnserver), also written in C that is known to have a security vulnerability. Although these two C programs are simple implementations of the FTP protocol, they allow us to evaluate the main elements of our proposed verification method initially. Additionally, in order to compare the effects of vulnerability detection, we compared our method with SPIKE (Bauer et al., 2017), which is based on generational fuzzer for protocol implementations. In our experiments, we have considered two sets of properties: "buffer overflow" and "arithmetic overflow". The experiments were conducted by hosting two machines, namely, a _host_ machine and a _guest_ machine. The host machine included an Intel Core i7 2.9 GHz CPU with 16 GB memory and was running Ubuntu 14.04. The guest machine was running Windows 10. The tools were running Ubuntu 14.04 system and the fuzzing tool SPIKE was running Kali Linux on the host machine as a virtual system. All benchmarks, tools, and results for this evaluation are available on a supplementary web page.1

Figure 1. _FuSeBMC Verification Framework._

[MISSING_PAGE_EMPTY:4]

## References

* (1)
* Azeit (2002) Dave ariel. 2002. The advantages of block-based protocol analysis for security testing. _Immunity Inc., February_ 105 (2002), 106.
* Anghini (1987) Dana Anghini. 1987. Learning regular sets from queries and counterexamples. _Information and computation_ 75, 2 (1987), 87-106.
* Chanenbaum (2002) A.Tanenbaum. 2002. _Computer Networks,th ed_. Prentice Hall Professional Technical Reference.
* Barton and James (1990) Barton and et al. James. 1990. Fault injection experiments using FTAI. _IEEE Trans. Comput._ 39, 4 (1990), 575-582.
* BELLARD (2005) F BELLARD. 2005. QEMU, a Fast and Portable Dynamic Translator, USENIX. [http://www.nong.org/qemU/](http://www.nong.org/qemU/) (2005).
* Black and Bojanova (2016) Paul E Black and Irena Bojanova. 2016. Defeating Buffer Overflow: A Trivial but Dangerous Bugs. _IIP professional_ 18, 6 (2016), 58-61.
* Cadar and Cristina (2008) Cadar and et al. Cristina. 2008. KLEE: Unassisted and Automatic Generation of High-Corere Tests for Complex Systems Programs. In _OSDI_, Vol. 8. 209-224.
* Chiopounov et al (2011) Chiopounov, Vitaly, Volodymyr Kuznetsov, and George Candea. 2011. SZE: A platform for in-vivo multi-path analysis of software systems. In _ACM SIGARCH Computer Architecture News_, Vol. 39. ACM, 265-278.
* Chipunov and Vitaly (2009) Chipunov and et al Vitaly. 2009. Selective symbolic execution. In _Proceedings of the 5th Workshop on (HotPel)_.
* Cisco (2018) Cisco. 2018. Cisco IDS XE Software Cisco Discovery Protocol Memory Leak Vulnerability. [https://tools.cisco.com/security/center/content/CiscoSecures/Advisory/cisco-s201809206-dcp-mem-trends-c/](https://tools.cisco.com/security/center/content/CiscoSecures/Advisory/cisco-s201809206-dcp-mem-trends-c/)
* Combs (2018) Gerald Combs. [n.d.]. Wireszk-Goep. [https://www.wireszk.org/](https://www.wireszk.org/)
* Faria (2008) JP Faria. 2008. Inspections, revisions and other techniques of software static analysis. _Software Testing and Quality_. _Feature_ 9 (2008).
* Gadehla and Cordeiro (2019) Gadehla and et al Cordeiro. 2019. EBMC v6. 0: Verifying C Programs Using k-Induction and Invariant Inference. In _International Conference on TACAS_. Springer, 209-213.
* George et al (2016) George, Sherin Mariam, and U.Sangeetha. 2016. Protocol testing with symbolic execution and rule based specification using multicore approach. _PT_ 24 (2016), 1609-1615.
* Katsonen et al (2001) Katsonen, Rauli, Marko Laakso, and Ari Takanen. 2001. Software security assessment through specification mutations and fault injection. In _CMS Issues of the New Century_. Springer, 173-183.
* King (1976) James C King. 1976. Symbolic execution and program testing. _Commun. ACM_ 19, 7 (1976), 385-394.
* Menegers et al (2018) Rafael Menegers, Herbert Rocha, Lucas Cordeiro, and Raimundo Barreto. 2018. MapCheck using LLVM and KLEE. In _International Conference on TACAS_. Springer, 437-441.
* Threat Encyclopedia
- Trend Micro USA., 2 pages. [https://www.trendmicro.com/vinfo/us/threat-encyclopedia/vulnerability/2255/sami-flip-server-user](https://www.trendmicro.com/vinfo/us/threat-encyclopedia/vulnerability/2255/sami-flip-server-user)
* Mikhail and Cordeiro (2018) Mikhail and et al Cardeiro. 2018. ESBMC 5.0: An Industrial-Strength C Model Checker. In _33rd ACM/IEEE Int. Conf. on (ASE'18)_. ACM, NY, USA, 888-891.
* Miller and Barron (1995) Miller and et al. Barron. 1995. _Inz revisited A re-evaluation of the reliability of VINK utilities and services_. Technical Report, UW-Madison.
* Munne and Taehiko (2016) Munea and et al Taehiko. 2016. Network protocol fuzz testing for information systems and applications: a survey and taxonomy. _Multimedia Tools and Applications_ 75, 22 (2016), 1475-1475.
* Qin and Liff (2006) Qin, S, and K. 2006. Liff: A low-overhead practical information flow tracking system for detecting security attacks. In _MICRO'06_. IEEE, 135-148.
* Sasanakis and Raimondas (2012) Sasanakis and et al Raimondas. 2012. Integration testing of protocol implementations using symbolic distributed execution. In _ICNP_. IEEE, 1-6.
* Shamegam and Chao (2016) Wen Shamegam and et al. Feng Chao. 2016. Testing Network Protocol Binary Software with Selective Symplectic Execution. In _CIS IEEE_, 318-322.
* Song et al (2014) Song, JaeSung, Cristian Cadar, and Peter Pietzuch. 2014. SYMBENNET: testing network protocol implementations with symbolic execution and rule-based specifications. _IEEE_ 126, 4014), 695-709.
* Stephens and Giovanni (2016) Stephens and et al Giovanni. 2016. Driller: Augmenting Fuzzing Through Selective Symbolic Execution. In _NDS_, Vol. 16. 1-16.
* US-CERT (2009) US-CERT. 2009. Understanding Denial-of-Service Attacks | CISA. [https://www.us-cert.gov/nex/lips/ST04-015](https://www.us-cert.gov/nex/lips/ST04-015)
* Vanhoef et al (2018) Vanhoef, Mathiy, Piessens, and Frank. 2018. Symbolic execution of security protocol implementations: handling cryptographic primitives. In _Izth \(\{\)USENIX\(\}\) Workshop on Offensive Technologies (\(\{\)WOT\(\}\) 18)_.
* Jhajie et al (2013) Wang, Jiaie, Tao Gu, Pulan Zhang, and Qixo Xiao. 2013. A model-based behavioral fuzzing approach for network service. In _2013 Third International Conference on IMCCC_. IEEE, 1129-1134.
* Sun et al (2017) Wen, Shameg, Qingjun Meng, Chao Feng, and Chaoying Tang. 2017. A model-guided symbolic execution approach for network protocol implementations and vulnerability detection. _PloS one_ 12, 11 (2017), e0188229.
* Sun et al (2017) Wan, Shameg, Qingjun Meng, Chao Feng, and Chaoying Tang. 2017. Protocol vulnerability detection based on network traffic analysis and binary reverse engineering. _PloS one_ 12, 10 (2017), e0186188.
* Zalewski (2015) Michal Zalewski. 2015. American Fuzzy Lop (AFL) fuzzer. [http://lamtuf.corredum.co/afl/](http://lamtuf.corredum.co/afl/)
* Zhang and Zhu (2018) Zhang and et al Zhu. 2018. A Novel Memory Leak Classification for Evaluating the Ambability of Static Analysis Tools. In _2018 IEEE on (PIC)_. IEEE, 351-356.
* Zhang and Ting (2017) Li Zhang and Vrijam L. Ting. 2017. A hybrid symbolic execution assisted fuzzing method. In _TENCON 2017-2017 IEEE Region 10 Conference_. IEEE, 822-825.